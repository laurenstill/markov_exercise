RAILS IS A GHETTO

I’ve more or less kept my mouth shut about some of the dumb and plain evil stuff that goes on in the Rails community. As things would happen though I’d take notes, collect logs, and started writing this little essay. As soon as I was stable and didn’t need Ruby on Rails to survive I told myself I’d revamp my blog and expose these fucks.

NOTE: This post is currently an open draft. Feel free to comment but it will have spelling and grammar errors and some paragraphs might not make sense. Check my blog and my atom feed to find out when I post the updates.

This is that rant. It is part of my grand exit strategy from the Ruby and Rails community. I don’t want to be a “Ruby guy” anymore, and will probably start getting into more Python, Factor, and Lua in the coming months. I’ve got about three or four more projects in the works that will use all of those and not much Ruby planned.

This rant is full of stories about companies and people who’ve either pissed in my cheerios somehow or screwed over friends. I can back all of them up from emails, IRC chat logs, or with witnesses. Nothing in here is a lie unless it’s really obviously a lie through exaggeration, and there’s a lot of my opinion as well.

The best part about ripping on these guys though is this:

If they have a blog, speak at conferences, publish papers,
or write books then they are public figures just like me.
This means that thanks to Larry Flynt I can stab them in the ear verbally, insult them, question their sexual orientation, and say anything that’s true and they just have to take it. Their only recourse is to write their pathetic little rebuttals in their stupid little blogs.

I’ll add one more thing to the people reading this: I mean business when I say I’ll take anyone on who wants to fight me. You think you can take me, I’ll pay to rent a boxing ring and beat your fucking ass legally. Remember that I’ve studied enough martial arts to be deadly even though I’m old, and I don’t give a fuck if I kick your mother fucking ass or you kick mine. You don’t like what I’ve said, then write something in reply but fuck you if you think you’re gonna talk to me like you can hurt me.

I’ll never be afraid of some pilsner fresh fat fuck who eats donut hamburgers and only gets exercise when he plays World of Warcraft on a DDR pad.

To prime the pump, let’s talk about Kevin Clark. Me and Kevin don’t get along because he once tried to demand some free tech support out of me for Mongrel. His dumb little company VaporSet had this stupid setup where the people deploying Rails didn’t have root access. I told Kevin that this was stupid and apparently it was Kevin’s idea because he told me “fuck you”. Ever since then Kevin’s been a mouthy little shit with nothing to back it up.

This particular discussion started with Kevin Clark deciding to tell me that my idea to restrict access to the main repository for Utu until it’s solid makes me a “dick”. But, read to the end of the chat for the punch line. It’s great.


Wow, rails is a ghetto. The little prick calls me a dick (and in private chat said he’d find me at the next conference but of course never did), then he deletes the fucking configure file for the project! Remember he was working on GNU lightning when I started chatting, so this means that it took an hour for everyone to figure out that his dumb fuck ass deleted it.

Why is this ghetto? Any experienced developer knows that autoconf configure files are a PAIN IN THE ASS to recreate. They almost always require special reconfigure calls, special m4 macros, or just time. You usually get them right, generate them once, and then leave them in your repository for all to use. To make it worse, Kevin actually wrote a supposed alternative to autoconf, and yet he doesn’t know the most basic thing about autoconf.

Only a fucking tool bag piece of shit would:

spend 10-20 minutes calling me names over IRC,
not have the balls to say any of that to my face,
say I’m a dick for wanting to use a different (established) publish/review model,
and then demolish such an important file for a project,
keeping everyone stumped and pissed for an hour,
therefore proving me right.
This is exactly what makes Rails a ghetto. A bunch of half-trained former PHP morons who never bother to sit down and really learn the computer science they were too good to study in college. BTW, this is true about Kevin as he’s an English major or something stupid (and it shows).

Hats off to you Kevin, you fucking prick. I’m enjoying my vacation too.

After this, I started thinking, since it was the first realization that I picked the absolute last wrong community to make my living in. They were all pricks, morons, assholes, and arrogant fucks who didn’t care about the art or the craft.

They were all a bunch of little ghetto fabulous princesses trying to make it in this tiny little Rails world and not enough brains between them all to make it happen.

TIED TO THE RAILS

I’ve been thinking this over ever since I realized that Mongrel and Rails more or less killed my career. During 2006 I was effectively homeless for about 4-6 months out of the year and made no money at all. During the rest of the year the little money I made was impossible to get, and many times I was simply not paid.

If it weren’t for the totally kick ass Obie Fernandez I’d probably be slogging away in some McD’s screaming, “you want fries with that?!” He got me a really good gig in Florida and I was able to get back on my feet. Obie rocks, and he’s also a good family man, treats his kids well, and is very smart. He’s one of the few gems of the Ruby world.

Before Mongrel I was building kick ass software for the NYC Dept. of Correction with a tiny team. We were doing innovative stuff like REST XML feeds of prisoner releases and RSS of prisoner transfers. It was fun, I was in charge, and things were pretty good.

Before that I built software for finger print readers, network protocols, designed business processes, lead software teams, created portals, and generally rocked as a consultant.

After Mongrel I couldn’t get a gang of monkeys to rape me, so forget any jobs. Sure people would contact me for their tiny little start-ups, but I’d eventually catch on that they just want to use me to implement their ideas. Their ideas were horrendously lame. I swear if someone says they’re starting a social network I’m gonna beat them with the heel of my shoe.

THE STORIES I COULD (AND WILL) TELL

One company tried to get me to sign a contract that required me to list all of my inventions, software, cooking recipes, works of art, writings, poems, essays, thoughts, ideas, patentable or unpatentable, prior to taking a 2 hour per week gig mentoring someone. The list of shit they wanted went on and on, and after I refused and just ignored them they still kept asking me.

Another company told me they had a great job for me and that I’d be perfect for them. I knew these guys so I at first trusted them, but what a mistake. Turns out that it wasn’t a job they had, it was an RFP that they wanted to bid for and put my name on the bid so they’d have an advantage. Alright, that’s fine but that means they’re using my name and reputation (that I earned) in a business transaction without telling me. Fine, I better get some fat cash. They then build the team and dole out the positions: Software Architect to the shithead who can’t code; Project Manager to the MBA asshole who talks like a car salesman; Lead Engineer to the guy using my shit to run his company. What do they give me? Nothing. I’m just Zed. Nobody needs my skills.

Other companies would hire me to fix something simple, I’d quote them $500 or so to do it, and then they’d refuse to pay if it didn’t take me a week to do. In one case I did something in about 5 minutes, sent off my automated billing PDF and they just flat refused. I had to work for another hour and even then they didn’t want to pay.

A company in NYC flew me out, put me up, and I gave them a cut-throat deal on my rate if they’d pay me quick. I needed the money to pay rent, so it had to be right after the two weeks of work. About the middle of the week I hear that the CEO isn’t going to pay me right away but is instead going to do NET-30 (an evil practice reserved only for furniture sales). I tell the guys that I got to go and I’d like my money, but they refuse, I fly out, and I don’t get paid for 60 days. What’d I do for them? Oh only a custom Mongrel server, a clean deployment to Mongrel from fastcgi, and a ton of training for their main man.

Then there’s the social network idiots. They all have a social network plus something fucking stupid to sell, but of course no MBA can actually code so they come running to me. However, there’s a slight problem. You see, I have a business degree you cock suckers. If you tell me that your social network will take on facebook because it includes baby pictures then I’m going to laugh in your face. They are an established player with CIA backing. You won’t wipe them out.

Google was a total riot. They offered me a job twice. I went with it, and they never responded. Probably because the job they were offering me—someone who’s been coding for 21 years, 15 professionally—was as a junior system administrator. What the hell does a junior sysadmin do at google? That’s probably like mopping the floor at a glory hole in Queens. I told them to review my resume and offer me a real position.

REVENGE OF THE ZEN PRICK

In Vancouver it was even weirder. There was no Rails there, and the only Ruby on Rails work was at this shitty little company I once worked for name Raymond James. I worked for them on a small gig, not doing much coding, just getting a project they screwed up out the door. Later I got into it with their “Development Manager” Alex Bunardzic over e-mail where he says something strange:

I would think twice before doing something like that, if I were you. As a Development Manager at Raymond James, I am privy to the work details you did for us some time ago (it’s all here, meticulously classified by [MANAGER]), and I must say that your references from that job are far from being stellar. To put things extremely mildly, you’ve ended up on our ‘not to rehire’ black list.
You may be looking for work, and people will naturally start asking around. I have plenty of contacts in the industry, and you know how people are when hiring—looking for references and for some feedback.

I’m afraid that, after just reviewing the code you’ve delivered here, I won’t be in the position to say many encouraging things about the quality of your work, not to mention your personality traits.
We go at it for a bit, because I didn’t actually write much code for them and I sure as hell didn’t write bad code since, you know, the damn project actually ran after I got there. Hell, I reverse engineered a Java library they bought but lost the source to so we could patch it. They even asked me to come in a few times and help on short gigs after my initial work. How the hell was I on a blacklist, why did they have a blacklist, why didn’t I know, and why the hell was Alex telling people this shit?

As the exchange unfolds (where apparently my use of foul language is bad but his threatening my livelihood is all right), Alex the Zen Master confesses that he got things wrong:

Here I need to apologize—I went back and looked over the documentation, and was shocked to realize that I’ve confused you with another person! That person’s name is Shai, and because that name was on a quick glance so close to Shaw, I’ve made a blunder and jumped at the premature conclusions.
...

So please scratch all the things I wrote previously concerning your past performance—all of that applies to some person whose name is Shain.
That’s right, this moronic idiot basically told (or just threatened to tell) everybody I was a shitty coder, refused to hire me, threatened me with slander, and tried to destroy me because he confused me with a “Shai” or a “Shain” in his blacklist. He even later tried to tell me that there wasn’t a blacklist.

Here’s the guy who is a development manager for an entire company and he can’t even tell the difference between two completely different people in some weirdo black list. All the more reason to leave Vancouver and try again somewhere else with people who don’t pretend to be Zen masters while they’re treating you like shit with a perfect half smile on their face.

HOW’D THIS HAPPEN?

Over and over again I’d run into these morons who would offer me tiny jobs, no jobs, insult my intelligence, treat me like all I can do is code, and when I didn’t fit that mold or wanted to charge them for the privilege they’d cheat me or laugh at me.

Here’s a bit of background on me: My education is in business. I have a BS in MIS and almost finished my MS but ran out of money. I’ve got more business education than most of the MBAs out there, and I have a nearly formal education in software development, modeling, statistical analysis, and sociology. I’ve done it all, but what does the slick talking shit head car sales MBA loser think I am?

Just a code monkey.
I have this rule that when life isn’t going well I have to look at myself very hard first, make the changes that might improve things, and then start looking at who’s stomping on my day.

After revitalizing myself, getting out of the Rails business (or trying), distancing myself from Mongrel, disconnecting from the Ruby community, and focusing on my business skills, I finally felt ready to figure out why the hell the Rails community is so completely and totally useless, stupid, and arrogant.

I believe, if I could point at one thing it’s the following statement on 2007-01-20 to me by David H. creator of Rails:

(15:11:12) DHH: before fastthread we had ~400 restarts/day
(15:11:22) DHH: now we have perhaps 10
(15:11:29) Zed S.: oh nice
(15:11:33) Zed S.: and that's still fastcgi right?
Notice how it took me a few seconds to reply. This one single statement basically means that we all got duped. The main Rails application that DHH created required restarting ~400 times/day. That’s a production application that can’t stay up for more than 4 minutes on average.

Let me put this into perspective for you: I’ve ran servers that needed to be restarted once in a year. They were written in PHP, Python, Java, C, C++, you name it. Hell, I’ve got this blog on a server I’ve restarted maybe 10-20 times the whole year.

Now, DHH tells me that he’s got 400 restarts a mother fucking day. That’s 1 restart about ever 4 minutes bitches. These restarts went away after I exposed bugs in the GC and Threads which Mentalguy fixed with fastthread (like a Ninja, Mentalguy is awesome).

If anyone had known Rails was that unstable they would have laughed in his face. Think about it further, this means that the creator of Rails in his flagship products could not keep them running for longer than 4 minutes on average.

Repeat that to yourself. “He couldn’t keep his own servers running for longer than 4 minutes on average.”

Assuming his statements are true (which we may never know) he basically duped us all.

Now I’m glad he did since Rails is a pretty nice idea, and it demolished the Java world I hated so much. What bothers me though, is that while all of the Rails Core fuck tards would insult me, tell me I was wrong, laugh at me, marginalize me, tell me I was a waste of space, that I “jumed the shark”, they were quietly taking my work and using it to improve their festering shit pile deployments.

In fact, in chats with me and them where I started to identify the GC, Threads, and IO all I ever got was denial from guys like Dave Thomas, Michael Koziarski, and Chad Fowler. Remember that nasty cgi.rb bug that is fixed with a monkey patch in Mongrel? Did you guys know that Michael K. and Dave Thomas pretty much threatened me into not releasing a Mongrel fix for the problem for three months? They actually let it sit for three months before other people crafted the cgi_multipart_eof_fix which I could include.

In the beginning, was this huge lie, but after that…

THEN THE IDIOTS CAME

My theory on why Rails is a ghetto is best summarized by an observation I made about Michael Koziarski. Here’s is fat fucking face just in case you don’t know who I’m talking about. See, here’s the thing about Koz: He’s got a big mouth he runs when he’s online, but in person he doesn’t say shit. He loves talking shit about me when I’m not around apparently, insults me when he wants, but the best thing about Michael Koziarski is this:

When he tells people I’m an asshole they go, “Zed’s such a prick I hate him.”

When I tell people Mike’s a fucktard loser, they say,

"Who?"
That’s right, dude works on Rails in some capacity, apparently writing tons of shitty fucking code with his butt buddy Nicholas Sekar. Yet, nobody knows him. He’s got more web sites than Elvis and Chuck Noris combined and nobody knows him. He’s written mountains more open source code than me and no-bo-dy knows him.

He’s a fucking loser, and man he used to bug me. Now however, I don’t give a shit about Rails so he’s a little fly. Rails is my money maker platform I don’t invest in at all. Rails could sink in the ocean for all I care and I’d roll on to my next big thing. I’ve done the right thing by giving Mongrel to a great team, and if Rails dies, then awesome because little useless pricks like MK will probably fall off the planet into that part of hell where shitty managers end up.

The best part about the whole thing is there’s potentially 10 new web frameworks that can take on Rails. Hell, Mongrel spawned or helped 5 of those. My favorite of those frameworks is Merb which is literally “Mongrel plus Erb” but now it uses Erubis mostly. What I love about Merb is that it proved you could make a fast thread safe Ruby web framework with all the same ideas as Rails and using most of the Rails gear at the same time. However, the joke is that before Merb the Rails Core morons would scream up and down you can’t make Rails thread safe. Ezra however proved them all wrong by just writing a better Rails than Rails and all thanks to Mongrel being so easy to hack and work with.

If the Rails guys had given me even an ounce of respect and listened to me I might have helped them, but instead I wanted to make sure that they didn’t rule the world because when I listened to them shit talk about the community that made them famous I wanted to scream.

Alright, but let’s say I’m totally wrong and Koz is really a great coder who’s just staying under the radar? Alright, remember the change to Rails to allow this?

http://mysite.com/controller/action;edit
That one little ’;’ was the cause of some serious pain for people since it’s actually not a proper request the way they interpret it. Requests with ’;’ in them are considered path parameters which are kind of like query parameters. Koz and DHH and crew added this, but I told them that’s not right, they should use something else like, uh, oh, maybe fucking ’/’. They ignored me. Did it anyway. Then when it was clearly obvious they were wrong (since Mongrel’s got a tight parser) who was out there defending this decision? Fucking Koz. Great programmers don’t defend stupid, they stamp it out and own up to their mistakes.

Fuck you Koz. You don’t speak.

Ruby on Rails has become full of people like Koz, with Koz the most senior of the wannabe smarties. Koz got lucky at best and injected his shitty coding into a good project, fucked it up, and then latched on to security as the way to get more control. Of course he doesn’t actually know anything about secure coding which is why his code seems to have lots of the bugs (go check out the date parsing shit. Clue: months don’t always have 30 days).

When I hang out with the Nitro, Factor, Django, Lua, Python, Lisp, or Mongrel crews I get to talk to super smart guys who have egos for sure, but have mutual respect. They craft nifty shit I love to play with, are fun to talk with even when I disagree, and don’t say mean shit when I’m not around.

With Rails I get scrawny cock suckers with carpal tunnel syndrome talking to me like they’re gonna eat my young. Their feeble PHP infected minds can’t grasp advanced shit like objects or closures. When you combine stupid businesses with stupid people using a stupid framework based on a big fat fucking lie on a shitty platform you get the perfect storm of dumbfuck where a man like me can’t find work.

There’s no work for a smart man in a town full of stupid.

THE HYSTERIA OF CONSULTANCY

Where I work the company is willing to blow huge amounts of money on a consulting firm or hardware, but ends up firing people when times get tight. It’s a universal mass hysteria that paying $100 – $200 per hour for a group of consultants is preferable to simply hiring good employees. At the rates companies pay these consultants they could hire 4 full time employees.

Consultancies used to provide a service by managing the entire project so you didn’t have to do much. Now with Agile and Pair Programming the consulting firms can dupe clients into helping them make the sausage, provide little to no services, yet still charge insane rates. What’s impressive is these consulting firms somehow charge rates that are 5 or 6 times what they pay their employees.

Think about that. How is it possible that your consulting firm has so much inefficiency they must charge 600% overhead? Are the services you get really that far above the base pay of that employee? Why the hell not just hire someone and have a long term learner who’ll be ready to work on anything?

Accounting, that’s why. When you hire a Full Time Employee (FTE) you need to account for it and budget them differently than if you pay a firm for a consultant. There’s several loop holes in the tax and accounting standards that make a consultant seem cheaper than a regular employee.

However, this is a mass hysteria. Eventually people will catch on that the quality they get for the price they pay isn’t there. A smart consultancy will figure out that they could undercut these idiot firms by simply using technology properly to cut costs and reduce overhead. Hell, you’ve got 600% overhead to work with. Should be easy to pull a Southwest Airlines on them.

Let’s take ThoughtWorks as a classic example of the hysteria. They decided to get into the Ruby on Rails game and went full bore. I was telling people right when Rails came out that doing it for internal projects at big companies would be a huge money maker. Nobody believed me, and now rather than all my smart friends working on cool applications for big money I have ThoughtWorks fucking up my party.

Before you continue this part of the rant ask yourself a question:

How did ThoughtWorks go from 0% Rails business to 60% Rails in just a few short months, but somehow didn’t hire that many top notch Ruby guys? Remember, if 60% of your business is Rails then 60% of your people need Rails training or else you have to hire more people. If they didn’t hire any more people than that means…the people they had were retrained. With two week training courses. Huh? How does that make them experts?

What happens if you do that is you have a group of former C# and Java guys running around writing shitty Ruby code and training on the client’s dime for huge fees.

Think for a second. ThoughtWorks charges its clients a premium price for expertise. They claim that their Agile methods and development expertise means they’ll produce a great result. This is why you pay them a premium. However, they reserve the right to control staffing, and you have very little say in the skills of the people they place.

Continue the logic further my friends with this little walk through consulting practices:

TW figures out it can make a mint doing RoR projects for dumb ass MBAs at dumbass companies.
TW goes for it and gets 60% of its business now all RoR.
TW realizes that they can’t hire enough Ruby people to do that. Actually, they didn’t really try too hard since that’d mean paying the new people a fair salary.
Yet, somehow they put 6-20 people on projects and claim that these people are Rails experts with a high standard of quality. These people actually had two weeks of training.
After each person has been on a project for a few months, they mysteriously get transitioned to another project, become “sick”, or generally leave.
They are then replaced with someone else who’s training is limited.
During their operations they seem to focus entirely on the process, but very little on the quality of the code. Sorry guys, but having a 1:4 code:test ratio is not focusing on code quality. It’s focusing on test quality.
Finally, when your project is in the dumps and it takes months to get simple things done you realize that you’ve been paying ThoughtWorks a premium for what is effectively a bunch of total newbies who are only there for a few months before they roll off.
You my friend got fucked in the ass. Congratulations because all the idiots who paid ThoughtWorks 6x times salary for junior ass wipes got taken and simply paid to train ThoughtWorks’ new crew.
How do I know this? Well, I’ve been a consultant for years and recently I’ve taken over two ThoughtWorks Ruby on Rails projects. BTW, they claim they don’t do “Ruby on Rails” projects, but actually do “Ruby” projects. They also claim they don’t do “eXtreme Programming” but do “Agile”. Doing this little semantics juggle means you can never hold them to any standard of quality.

In the two projects I’ve taken from ThoughtWorks I found mountains of horrible, horrible code. They of course try to pull the classic “there’s many ways to do everything in programming” but this time they kind of get caught because Ruby on Rails means stay on the Rails. There is an established best practice way to build web applications with Rails and that’s the entire point of the system. When ThoughtWorks fucked up these projects they did it in such a completely deviated way that it was impossible to defend.

Additionally, the people they placed on these projects were not well trained at all, had no idea about simple Ruby idioms let alone good design, and spent more of their time drinking and having fun than actually getting shit done. At the last project they actually had bottles of Pedialyte in the fridge to help with their hangovers after wild nights partying.

After ThoughtWorks left the most recent project we revamped the team. We got rid of pair programming, cut down the number of tests, started cleaning more and more code out, got rid of their shitty tools, and we all started leaving at 6pm. What happens?

We doubled our productivity with fewer people. Yes, that is a verifiable metrically validated claim I can back up. Just like the horrible quality of the code, their idiotic defense of it, and their very bad job at designing even the basics of the business model required. Remember, they are testing and svn whores so their failure on these two projects is very well documented.

However, what really ticks me off about ThoughtWorks isn’t the way they fucked up these two projects. I’d take ThoughtWorks over IBM, Accenture, or BearingPoint any day of the week. ThoughtWorks’ competitors are even worse, so I’ll take the lesser of ten evils any day. What pisses me off is that I know they’re responsible for turning Ruby on Rails into the next Visual Basic. Why? Because they wrote in a position paper that Ruby on Rails was like Visual Basic. Yes, they did that. They compared Ruby on Rails to probably the most technically vilified language in the history of computing.

Here’s my prediction about ThoughtWorks: They’ll continue to screw customers over by training their employees on their client’s dime and write tons of fucked up software. The bad results from ThoughtWorks will kill Ruby on Rails for companies as these companies are left with a bad taste from bad implementations.

FROM INDUSTRY TO CORPORATE

ThoughtWorks is simply taking advantage of a pattern where new technology goes from fringe to corporate and then dies. A great example of this is Java Portals. They started out on the fringe at universities and non-profits, where they were mildly successful. Then they migrated into the corporate world where they were complete disasters, and finally the risk averse government picked them up for even less success.

How do I know this? I worked on portals for their entire life and followed them through this process. Go look. I did some of the first work on uPortal, then I worked on portals in companies, and then worked on them for the government.

Ruby on Rails is following the same trajectory I’m afraid, and ThoughtWorks is milking it while they can. First it started on the fringe in start-ups and a few lonely places where it’s having mixed success (mostly due to the poor performance of the Ruby platform). Now it’s getting adopted internally at companies where of course it’ll get fucked up again and die off. After that it’ll move to the government sector where it will languish along with it’s new found buddy COBOL.

Oh, did I mention ThoughtWorks compared Rails to COBOL as well? Awesome.

FIGHTING CONSULTING FIRMS

I have a few pieces of advice for people about to hire any company like ThoughtWorks. There’s just a few simple strategies you can follow to make sure you get the most out of them and get your money’s worth:

Make sure you have the right to see every resume and interview each consultant they place. Treat them like new hires and don’t let anyone who’s not worth the rate you’re paying on the team.
Demand a variable rate based on the position of the person and their experience.
Demand that no employees can leave the project to work on another project. These placements have to be for the life of the project or until the employee quits.
Require that you have the right to have someone replaced if they are not immediately capable. Part of what you’re paying is that a ThoughtWorker should be able to drop in commando style and just start working. The reality is they are usually totally lost anyway.
Seriously consider recruiting one full time employee as a team lead, another as a project manager, and then staff the rest of your team with independent consultants. You’ll find that you get more control and better quality at a lower price.
Finally, a company like ThoughtWorks uses bizarre socialization processes and weird shit like Neuro-Linguistic Programming to enslave their employees into working more hours than needed. That shit about “can’t leave with a broken build”, pair programming, hazing rituals, firing people who don’t conform, and other unprofessional behavior mostly exists to make employees pliable pawns.

Why? Because ThoughtWorks pays these people a salary that is fixed and considered a sunk cost. If they pay someone 60k/year and that person works 40 hours/week then they are paying them about $29/hour. If they convince this idiot to work 60 hours/week then they are basically paying the moron $19/hour. If they can push them to 80 hour/week then these idiots are actually making $14/hour. You can make $29/hour managing a fast food joint.

The further and harder ThoughtWorks (or any consulting firm) pushes its employees the more money they make because then they charge the client for each fucking hour. Get it? If they push an employee to 60/week they not only reduce the cost of that employee but also increase the billable hours. Hell, even if they don’t charge for those hours they still make more money just by reducing costs.

Now I’ll admit I didn’t see ThoughtWorks do this quite as much as I’ve seen IBM Global Services, Accenture, and BearingPoint do it, but they still do it. My observation about ThoughtWorks is they’re really really really fucking weird about it. I saw them pull passive aggressive shit like picking on a single employee high-school-nerd-vs-jock style until he conforms or quits.

What’s this got to do with your project? Well, if you have a mix of ThoughtWorks employees and your own then be careful that the ThoughtWorkers don’t warp your employees as well. I’ve seen it once already where a room full of ThoughtWorkers would thrash and trash on one poor employee simply because he disagreed with their approach to a problem. Or, having special boards on the wall with “How Many Times Frank Is Late”. Or, holding “dev lunches” (which I called “dev lynches“) where they thrash client employees with alternative opinions in order to maintain their stupid operations.

I’ve seen it, and they do it. Be careful of it as you’ll lose people who are smart and not susceptible to that crap, or you’ll have a bunch of brain washed idiots at the end of the project. It’s also a horrible way to treat a client so don’t put up with it.

MORE TO COME

This is a long rant I’m writing in serial form. Stay tuned for more about Ruby conferences and why they suck, and why the Pickaxe book is what killed Ruby.

The Master, The Expert, The Programmer

I spent most of my high school years living on Guam trying to stay alive long enough to leave and start a new life. It wasn’t a good time for me, and about the only good thing that came out of it was I started studying martial arts. These days I’m a lazy bastard, but back in the day I studied everything I could get my hands on. It was rough, but I came out of it fine and I’ve since used my knowledge of martial arts in just about everything I’ve done. Each one I studied taught me something different. Capoeira taught me that being balanced is more about being able to adapt and flex than root your stance. Aikido taught me that attacking a problem directly is rarely the solution. Muay Thai taught me that destroying the base will destroy the building. I studied Muay Thai, Ninjitsu, Wing Tsung, Judo, various weapons, and even spent a year getting the crap beat out of me by some rough sword fighters in the SCA. Unfortunately I never studied anything long enough to be considered very good at it. I just took what I found and moved on to the next interesting thing. What does this have to do with programming?


I have met quite a few false masters though. These are people who may be very good, and much better than myself. I usually took classes from them, but not because I thought they were “grand masters”, or “masters” or anything. These guys (they were always guys, women are hard to find) were flashy. They could do neat things, could teach really complex techniques, and could tell you every single thing about their martial art possible. Charging you for lesson after lesson was how they made their money after all. Teaching you movie stunt man moves was how they attracted and kept students.

Yet, none of these gentlemen were what I’d consider masters. They were great teachers, and I don’t want to insult them in any way, but none of them were masters of their art. None of them could clearly and simply explain their martial art’s concepts. When I’d ask a complicated question, they would give me a complicated answer. Sometimes their answers were just wrong. Like one guy who tried to show everyone how to break out of an arm lock by punching. He asked me to do the arm lock since I studied Judo, so I did it right and made sure that I rotated with him as he tried to punch. He kept trying to punch me, and I just kept rotating. I really wasn’t paying attention until he suddenly burst out, “Dammit stand still so I can demonstrate.” I said “sorry” but thought, “Yeah, like I’m gonna stand still.” He could have kicked my ass two ways from Sunday, but a simple arm lock frustrated him?

The main thing I noticed about the experts I’ve encountered is they are into impressing you with their abilities. They are usually incredibly good, but their need for recognition gets in the way of mastery. Everything they do is an attempt to prove themselves and in order to do this they must perform like an actor on stage. There’s nothing wrong with this, and I don’t think the expert can become a master without going through this stage in life. At some point though, the expert becomes comfortable with themselves or fed up with impressing everyone and starts to look inward to the core of their art.

The Programmer

I’m going to come out looking like an obnoxious pompous asshole here, but I’m not trying to be one. I’m simply trying to explain something I’ve noticed about the difference between code written by myself and that which “frustrated experts” write. I’m in no way saying that I’m some kind of grand master coder. I consider myself an advanced expert at best.

What I notice is that my peers are progressing to more and more complicated and convoluted designs. They are impressed with the flashiest APIs, the biggest buzzwords, and the most intricate of useless features. They are more than happy to write endless unit tests to test their endless refactoring all the while claiming that they follow XP’s “the simplest thing that works” mantra. I’ve actually seen a guy take a single class that did nothing more than encapsulate the addition of two strings, and somehow “refactor” it to be four classes and two interfaces. How is this improving things? How can more somehow equal simpler? This should never be the case.

These are the actions of an expert. These experts are very smart, capable, and skilled, but they are too busy impressing everyone to realize that their actions are only making things worse for themselves. In the end all of their impressive designs are doing nothing but making more work for themselves and everyone around them. It’s as if their work is only designed for getting them their next job, rather than keeping them in their current one.

I used to be this way. I used to love complicated designs and read everything I could about complicated technologies. But as I get more experienced and “older” as a programmer I find complex things just annoying. They aren’t a mental challenge to understand anymore, they are just irritating. I’ll pick apart the flashy crap, boil down the technology to its essence and then come up with a much simpler design for the task at hand almost every time.

What worries me though is how the experts react to my simplified designs. Typically they’ll say that what I’ve written is not “following best practices” or “isn’t well designed.” They’ll propose these endlessly complex designs with endlessly imagined failure scenarios, and not realize that what they are doing will be a nightmare to maintain. The experts will then saunter off to implement their Flaming Tower of Babel without any comments, horribly complex mock enabled tests, making sure EVERY SINGLE CLASS HAS AN INTERFACE, and ending every class with “Impl” because, well, that’s the best practice. After implementing it they’ll continue to complicate the design even further with endless seemingly aimless refactorings for no other reason than to refactor. And when they’re done, I’ll go in and read through their code and cry.

This is the actions of an expert. They love complexity because the art is still new to them, something which should be explored. A list is not just a container, it’s a linked list, or red-black tree, or doubly linked list. To me, it’s just a container. I realize now that they’re missing my need for simple beautiful things. They don’t love quiet elegance, and would rather shout their superiority from the top of the mountain. Meanwhile, I’m just a lazy old man who wants to get his job done and write something without any wasted energy. I want to climb the mountain with the least amount of effort and their shouting is causing an avalanche of bad code.

The Coming Professional Master

Programming is a very new discipline, so there’s not too many master programmers out there. What’s worse is that the few people I would consider masters aren’t very exemplary of the software profession and art. They are typically professors who never write anything under a deadline and are given complete artistic freedom to develop whatever they want. Take Donald Knuth, who was able to take three years off from teaching in order to complete TeX. There’s no way I could get away with telling my employer that it’ll take me three years to finish their product. Knuth is basically a “master amateur”. A guy who worked in a complete utopia and was able to hone his skills without interference. I would compare him with a man who became a master by studying at a monastery for for his entire life.

In contrast there are masters in the martial arts who learned their art as a means of survival and became masters in a realistic and hostile environment. We don’t have anyone like this in the programming profession, or at least I haven’t met any. I believe that my generation of developers will produce the kind of masters forged in the real professional world. (Yes, sorry professors, if you can’t get fired for missing a deadline then you aren’t a real programmer working in the real world.) Hopefully software development will continue as a profession and we’ll see a crop of master programmers emerge from industry to challenge the existing amateur masters. But, if the current experts continue to push for ever more complicated, convoluted, involved, and “impressive” designs and ideas then we’re in for a world of hurt.

So my final plea for all my fellow experts out there: Can we please start pushing the art and science of software development toward the austere? I’d love someday to hear a young coder tell a story about someone they idolized like, “There was this guy I worked with who once optimized a complicated red- black tree getting 300% performance boost. I was baffled and ask, ‘How’d you do that? That’s impossible.’ To which he responded…”

“‘That’s my linked list my son.’”

Programmers Need To Learn Statistics Or I Will Kill Them All

I have a major pet peeve that I need to confess. I go insane when I hear programmers talking about statistics like they know shit when it's clearly obvious they do not. I've been studying it for years and years and still don't think I know anything. This article is my call for all programmers to finally learn enough about statistics to at least know they don't know shit. I have no idea why, but their confidence in their lacking knowledge is only surpassed by their lack of confidence in their personal appearance.

A bit of background about me is in order. I got interested in statistics when I started to read about the history of mathematics and how statistics radically changed the way science was done. Before statistics the belief was that the world fit into perfectly mathematical models, and that any error we find is because we don't have the models right. This is thanks to Descartes convincing everyone that math is reality, and that we're just full of bullshit. Eventually, every major science adopted an empiricist view of the world. Except Computer Science of course.

My part in this little drama is that I'm a weirdo who's studied more sociology, business, economics, and history than I've studied computer science. I have taken a bunch of math classes, studied statistics in grad school, learned the R language , and read tons of books on the subject. Despite all of this I'm not at all confident in my understanding of such a vast topic. What I can do is apply the techniques to common problems I encounter at work. My favorite problem to attack with the statistics wolverine is performance measurement and tuning.

All of this leads to a curse since none of my colleagues have any clue about what they don't understand. I'll propose a measurement technique and they'll scoff at it. I try to show them how to properly graph a run chart and they're indignant. I question their metrics and they try to back it up with lame attempts at statistical reasoning. I really can't blame them since they were probably told in college that logic and reason are superior to evidence and observation. Even the great Knuth once said: “Beware of bugs in the above code; I have only proved it correct, not tried it.”

A Blind Man On A Planet With No Sight

I'm sure you've all thought about it at some point. “Imagine you're on a planet where everyone was blind, and you're the only one with sight. How would you describe the sunset?” It's commonly something done as an exercise in high school and it's retarded. If this planet were populated with programmers though it would be really interesting.

Zed: Wow, the sunset here is a brilliant blue.
Joe Programmer: No, you're fucking wrong it's red asshole.
Zed: Uh, it's blue. Guy with vision here. Remember?
Frank Programmer: Yeah, it's red man. You're an idiot. See, I can hear the way it makes the air move so I know it looks red.
Zed: Look! I'm the one who can see! It's blue.
Joe Programmer: I have written huge web applications in every language and even programmed the original VAX. I know that sunset is red.
Frank Programmer: It's red because of the heat it generates on my arm. Yes. I'm sure that's it.
Zed: Fuck! Fuck! I have eyes! You do not! See Exactly Arrggh! I'm going to get a burrito.
Joe Programmer: That guy is such an asshole.
Frank Programmer: Yep. Still sounds red to me though.

This is how I feel when I try to explain why someone's analysis isn't quite right. I grab one of my many statistics book, open up my R console, start to draw up some graphs and show them how to do it. Next thing I know, I'm getting the cold shoulder or told I'm an idiot. It's even worse when the person is a programmer and I'm showing them that they have work to do.

Another analogy is when I met a guy from Arkansas who said that perpetual motion machines could work. “Yesir, perpetual motion machines~~~~or PMMs as Billy Bob Dunsfield down the street calls 'em~~~~are a reality. I read it on the eenternet yesterday. Yesir.” I'm usually just stuck with even where to begin. “Don't believe what you read on the Internet…” No, this is the guy who reads Hustler, so I don't want to keep him from reading more. “You see, there's this law of…” No, physics won't come into the conversation at all. I'm just stuck.

The difference though between some hill-billy from Arkansas and a clueless programmer is that the programmer should know better. He's probably educated, smart, and hopefully both (you'd be surprised).

Oh, and you wonder why I say, “he”? I never have this problem with female programmers. Maybe it's because I'm tall (6'2"), or nicer to them, but they always speak rationally and are really keen to learn. If they disagree, they do so rationally and back up what they say. I think women are better programmers because they have less ego and are typically more interested in the gear rather than the pissing contest.

My List of Pet Peeves

I could make this list go on and on forever, but I'll just rant about the top things that irritate me to no end. These are things you'll see all over the IT industry. Performance measurements, capacity planning guides, product literature, and anything Microsoft writes about Linux. I'll detail each annoyance, and then describe how you can stop doing it, and what to read to get help.

Power-of-Ten Syndrome

“All you need to do is run that test [insert power-of-ten] times and then do an average.” Usually the power-of-ten is 1000, but it will be 10 if the test takes longer than 2 minutes (which is the exact attention span of the average programmer). I'll cover “average” later on, but there's several problems with the power-of-ten choice, which I'll demonstrate with the usually given “1000 times” figure.

How do you know that 1000 is the correct number of iterations to improve the power of the experiment?

What's that? You don't know what “power” is? It's basically the chance that your experiment is right (not quite but close enough). There's some decent mathematics behind determining power, and you can even run a single function in R to find out appropriate sample sizes given your accuracy needs. Take a look at power.t.test power.prop.test in R for information.

How are you performing the samplings?

1000 iterations run in a massive sequential row? A set of 10 runs with 100 each? The statistics are different depending on which you do, but the 10 runs of 100 each would be a better approach. This lets you compare sample means and figure out if your repeated runs have any bias.

How do you know that 1000 is enough to get the process into a steady state after the ramp-up period?

A common element of process control statistics is that all processes have a period in the beginning where the process isn't stable. This “ramp-up” period is usually discarded when doing the analysis unless your run length has to include it. Most people think that 1000 is more than enough, but it totally depends on how the system functions. Many complex interacting systems can easily need 1000 iterations to get to a steady state, especially if performing 1000 transactions is very quick. Imagine a banking system that handles 10,000 transactions a second. I could take a good minute to get this system into a steady state, but your measly little 1000 transaction test is only scratching the surface.

What will you do if the 1000 tests takes 10 hours?

How does 1000 sequential requests help you determine the performance under load?

You run 1000 test sequentially and then find out that the system blows up when you give it a parallel load. Now you're back to square one because the performance characteristics are different under parallel load.

If all you do is run 1000 and then take an average, then how do you spot places where the system is really hurting?* Read the “Averages Only” section for more on this.

A graph can really demonstrate this problem well. Using the following R code:

> a <- rnorm(100, 30, 5)
> b <- rnorm(100, 30, 20)
I construct two sets of 100 random samples from the normal distribution. Now, if I just take the average (mean or median) of these two sets they seem almost the same:

> mean(a)
[1] 30.05907
> mean(b)
[1] 30.11601
> median(a)
[1] 30.12729
> median(b)
[1] 31.06874
They're both around 30 (which is what we requested with the second parameter). This is where most programmers would start to piss me off, because if you take a look at the following run chart of the samples you can see the difference (blue is a, orange is b):



The third parameter tells R to give samples with different standard deviations. This makes the range of possible responses “wider” and gives you two wildly different charts even though they have the exact same mean and nearly the same median. Even better is the results of the summary function in R:

> summary(a)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  13.33   27.00   30.13   30.06   33.43   47.23
> summary(b)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
 -15.48   16.90   31.07   30.12   43.42   80.86
Without even doing a nice graph you can see that the ranges are totally different.

Averages Only

This one pisses me off the most as it is so obvious. It usually happens when a programmer states that his system can handle “[insert power-of-ten] requests per second”. I then see the power-of-ten and raise a red flag. A power-of-ten isn't really bad, as long as it's arrived at through a decent analysis. But typically it's torn out of a monkey's ass and thrown on a wall with a plop.

The most troubling problem with these single number “averages” is that there's two common averages and that without some form of range or variance error they are useless. If you take a look at the previous graphs you can see visually why this is a problem. Two averages can be the same, but hide massive differences in behavior. Without a standard deviation it's not possible to figure out if the two might even be close. An even better approach (with normally distributed data) is to use a Student's t-test to see if there are differences.

Let's look at the standard deviation for our two samples:

> sd(a)
[1] 5.562842
> sd(b)
[1] 19.09167
Now that's a difference! If this were a web server performance run I'd say the second server (represented by b) has a major reliability problem. No, it's not going to crash, but its performance response is so erratic that you'd never know how long a request would take. Even though the two servers perform the same on average, users will think the second one is slower because of how it seems to randomly perform. Of course, this can't be a server measurement since it has negative timing measurements, but it is only an example for this standard deviation.

Why is this so important? Here's two more graphs to illustrate how important consistent behavior is to performance measurements—and actually most process oriented measurements. The first graph is the a set and the second graph is the b set:



Normally you don't get such nice graphs from performance measurements, but the idea is still the same. The first graph fits well into a very nice normal curve. The curved line pretty closely matches the histogram it models. This is what a consistent process looks like.



This second graph though shows a total mess of a process. A run chart would give you a better view, but this illustrates an important point that badly behaving processes tend to not fit their supposed distribution. We know this is supposed to be a normal distribution, but look at it. It's all slumped to the side and doesn't even look at all like it's distribution.

The moral of the story is that if you give an average without standard deviations then you're totally missing the entire point of even trying to measure something. A major goal of measurement is to develop a succinct and accurate picture of what's going on, but if you don't find out the standard deviation and do at least a couple graphs then you're screwed. Just give up man. Game over. Game over.

Confounding, Confounding, Confounding

Ah, confounding. The most difficult thing to explain to a programmer, yet the most elementary part of all scientific experimentation. It's pretty simple: If you want to measure something, then don't measure other shit. Wow, what a revelation. It is a lot more difficult to do in a lab and especially in agriculture where most of this crap was thought up in the first place. Programmers have no fucking excuse though since they can easily remove confounding by isolating systems.

Here's an example of why confounding is so wrong. Imagine that someone tried to tell you that you needed to compare a bunch of flavors of ice cream for their taste, but that half of the tubs of creamy goodness were melted, and half were frozen. Do you think having to slop down a gallon of Heath Crunch flavored warm milk would skew your quality measurement? Of course it would. The temperature of the ice cream is confounding your comparison of taste quality. In order to fix the problem you need to remove this confounding element by melting all the ice cream.

Alright, well, I guess you could freeze them all too but you get the idea.

How do you fix or even detect confounding? Well, in “the real world” it's a bitch~~~~and sometimes it's impossible~~~~so some super smart motha fu.. (shut your mouth) came up with all sorts of ways to reduce the impact of confounding. One way is to randomize the confounding element so that its effect is not influencing the element under investigation. If you have to find out which fertilizer is the best, but the water and soil have different properties over your massive 20 acre field, then you need to randomize where you put what fertilizer. It gets even more complicated since you might randomly put them in a really bad formation, so these super smart people came up with ways around that too.

Hold on though, we're fucking programmers not farmers. If we want to take one single line of code and test it then we can. If we want to only verify one single query on a database then what's stopping us? Stupidity that's what. Programmers just don't get confounding and companies use it against them by writing “case studies” comparing wildly different systems in performance or security that are chock full of confounding elements.

The classic example of this is the Pet Store debacle where Sun put out an example application showing how to do J2EE right (which was really more wrong than a transvestite pregnant with triplets). Then Microsoft came along and re-implemented the whole thing using ASP that smoked the Java Pet Store—even though it was implemented just as wrong. The confounding in the Pet Store comparison though was so bad that it was impossible to really compare the two. They were different systems, had different URLs, different form elements, different backend databases, and the test procedure was totally bogus. The comparison claimed to measure X number of “users”, but didn't cover single page execution, database configurations used, system level tunings. Of course none of that is useful because even that just confounds shit even further.

For the Pet Store experiment to be meaningful it should have tried to keep every damn thing it could the same except for the minimum of different elements. The same databases, operating systems, file layouts, forms, HTML tags, logic flow, everything possible. The only different element should have been the ASP vs. JSP and the Servlets vs. VB hackery. Even better would have been to not use a full application in order to avoid confounding an entire application design on the measurement of speed to render functionality.

Being able to remove confounding elements to get to the core of a problem is also a valuable analysis tool outside of measurement. I once worked for a financial services company that was rolling out a new application to its sales team. We spent the whole Sunday night getting this thing rolling and the next morning we kept running into these weird 2 or 3 minute delays on some queries. The manager in charge of the project was throwing fits and threatening to fire our entire team for incompetence. He especially picked on the database admin for whatever reason, but our direct manager was very calm and rational about it. She (remember what I said about women) asked me to look at it and see what I could figure out.

The ranting manager was claiming it was the DBA's database and he was screwed. It was our programming that was causing the problem. It was this and it was that. I checked out the program and the queries and nothing seemed wrong. I decided to break down each element of the chain in the request processing to see what was causing the problem. JSP rendering? Nope, that was sub-second response on average with a sub-second standard deviation. Controller code? Nope. Microsoft SQL database? Nope. A small harness that ran all the queries in the application showed those to have great and consistent performance.

Then I hit the DB2 database and about crapped my pants. Almost all of the queries performed great, except one query that had sub-second response on average, but a 60 second standard deviation! This was the query. I made a chart of all the different queries, marched into a meeting, slapped them on the table and said, “It's not the database, it's IBM's DB2 configuration. Here's the time measurements to prove it.”

The next day we had IBM fixing the problem (turned out to be a single update index command) and we all kept our jobs. That's what a proper analysis method can do for you.

The Definition of “User”

I worked with this idiot we'll call Mr. BJ who would constantly say that my measurements were crap. I'd compare the performance of X and show that it wouldn't meet our coming student storm (it was a university) and he'd tell me that I'm full of it since I didn't measure how many “users” the system could handle. I kept asking BJ, “define user.” The best he could come up with was, “You know, click around a lot and fill out some forms. Like a user!”

Before you can measure something you really need to lay down a very concrete definition of what you're measuring. You should also try to measure the simplest thing you can and try to avoid confounding. Yet still I see software developers begging for gazillions of dollars to buy some crap tool that doesn't even mention “standard deviation”, but throws “user” around like it's Dr. Phil treating Robert Downey Jr. for heroin addiction.

What gets me though is most IT people can't even grok people's facial expressions, but they'll trust anything that claims it measures “the average user”. I'm sorry to say boys and girls but there's entire industries and scientific disciplines trying to figure out the average user. Your piddly little JMeter analysis with it's lousy graphs and even worse statistics won't tell you crap about your users.

It especially won't tell you the one thing you need to know for performance measurements:

How much data can go down this fucking pipe in a second?

That's all there is to performance measurement. Sure, “how much”, “data”, and “pipe” all depend on the application, but if you need 1000 requests/second processing mojo, and you can't get your web server to push out more than 100 requests/second, then you'll never get your JSP+EJB+Hibernate+SOAP application anywhere near good enough. If all you can shove down your DS3 is 10k/second then you'll never get that massive 300k flash animation to your users in time to sell them your latest Gizmodo 9000. Face it, users are both useless for fixing their computer and as a measurement of speed.

Measuring anything else first is like trying to see who has the fastest car by going to the super market to get eggs. All you get out of that exercise is broken eggs.

Where To Get Help

I've read a lot of books on the subject, but here's a few that you can look for on your favorite corporate book pusher site:

There's also several books on statistics and the software development process which you can apply to your work directly. Finally, you should check out the R Project for the programming language used in this article. It is a great language for this, with some of the best plotting abilities in the world. Learning to use R will help you also learn statistics better.

Maxipads Are Better Than iPads

I am about as interested in the iPad as I am in Maxipads. I’m not against them, I’m actually quite for them. I understand that a large majority of the population probably prefers Maxipads. Another group probably hates them. There’s probably discussions about the benefits of Maxipads vs. Minipad vs. Tampons. I don’t think about them. I don’t plan on buying any unless someone asks real nicely. I just really don’t need any Maxipads or even think about them since, you know, I have a penis and shit.

But you know why Maxipads are better than iPads? Because the people who buy Maxipads don’t fucking talk about them all day!

Seriously, when it comes to the iPad there’s two people who just need to STFU.

Groupies who want Steve Jobs inside their fanginas know that this is just a giant iPhone. Suck it up. It’s nothing revolutionary and that’s perfectly great. It’s just a simple consumer device and you’ll love it no matter what so quit pretending like it’s as revolutionary as when they made BSD look nice or when they switched to faster Intel CPUs. Apple’s good at getting your little fangina wet so fantasize about it and twiddle your “little man in the canoe” until it comes out.

Haters also need to STFU about the openness. Answer this: Do you know anyone using a fucking tablet PC? No? You know why? Because there is no market for tablet PCs. At least not until Apple just created it for you. You should be thankful. You see, just like AOL vs. Internet, the very first company to market can make a lot of money with a walled garden. The regular Joe’s who will buy these things just want shit to work and will pay for that convenience. Of course Apple’s going to make this thing a walled garden. Big fucking deal since that’ll create consumers ready for something more.

Just like AOL vs. Internet, this means there will be a shift in about 2–5 years when the market for tablets that Apple just created finally realizes that walled gardens blow. It’ll probably be the day they find out that they can get porn on the Dell or HP tablet because it has Flash. Or that they can steal all their music with Bittorrent instead of buying it from iTunes (that piece of shit).

So, instead of fucking bitching and griping in your best Comic Book Guy voice about how it’s not open, you should close your nerd trap and get off your ass to make the successor to the iPad. By the time you get something that works well, the market Apple has created and neutered will be ready for something better.

But please, do it right this time and make that shit actually easy to use. In fact, if you make it so programmers hate it then regular people will fucking love it.

Of course, I still won’t care because I can’t code on a tablet and it’s not a guitar.
Yeah, Don’t Move To NYC To Do Your Startup (Yet)

Let me tell you a little story my people. I had a friend of a friend get me in contact with a guy who ran a small NYC hedge fund. This guy was very nice and very professional and had an interesting idea he’d already implemented and which was making his fund fairly wealthy. What he wanted me to do was recreate the web site in Ruby on Rails.

He eventually went with a programmer he knew and trusted, which was probably a good thing since I didn’t want to do a site in Ruby on Rails. During the course of our meetings I asked him how much his “small” hedge fund was worth.

He told me:

30 BILLION DOLLARS

That’s right. His little hedge fund was worth more money than thousands of Silicon Valley startups combined on a good day. He wasn’t being modest either. It was “only” worth 30 billion dollars.

Here’s another fun experiment, do a search for say “capital -bank” or “fund”. You know, words found in hedge fund names. Here’s an example of just the few blocks of Manhattan near where I lived:



There’s a few false positives, but that’s still a massive number of “small” funds in just a 12 block area of one stretch of NYC. We’re not even talking about the big boys in mid-town.

Or, how about this: A while back, Bloomberg (another guy who made a lot of BILLIONS off banks in NYC) got together with some funds and put up 2 million (yes “MI-LLION”) to get NYC’s startups going. They were going to give out 200k each through an entity called NYC Seed. Yes, they were going to kick start NYC’s startup scene with 10 companies and hand them barely enough money to pay rent for 3 months at NYC prices.

That same day, the CEO of BofA announced that he wanted to give back the 20 BILLION dollars he took in bailout money because he didn’t really need it.

Imagine that this 20 BILLION went to funding startups in NYC. That’s 100 thousand startups at the 200k financing rate.

The CEO of BofA basically was given the option of taking or leaving a sum of money that equaled 100000 startups. If each of those startups hired 5 people you’d have a startup culture the size of some large American cities. Yet, this dude was able to take it in a short amount of time and give it back the same way I might borrow five bucks from a friend.

Remember when the dot-com crash happened in 2001? Was there a bailout? Nah, no bailout for those damn nerds and hippies, even though the banks caused the crash by pulling pump-and-dump schemes with shit technology companies nobody should have invested in. Nope, your technology isn’t worth a bailout.

Meanwhile banks have received trillions, mostly through special lending and no-interest massive loans they’ll eventually pay back (cough), with the majority of that free money going to the few remaining big banks in NYC. You of course will pay for that with your taxes and not get a dime of it back.

These little tidbits of information should tell you something that is glaringly obvious about NYC.

Your Million Dollar Tech Is Chump Change Compared To Finance

Money is in limited supply. Well, unless you are Paulson and feel the Fed is your personal Goldman Sachs money press. Anyway, people with money have a limited amount of it and want to put it to good use. Now, imagine you got a spare 20 million to throw around and you want to invest it someplace so you’re going to look for some companies to fund. Here’s your choice:

Option A: A couple of nerds who kind of smell and have this really cool thing that you don’t really understand involving the interwebs which has a very high chance of failing taking all your money with it, or if it succeeds making a whopping few hundred million.

Option B: A couple of slick Harvard MBAs who take you out for rows of coke in Atlantic City, buy you a blowjob or two, and tell you they have a “tiny” hedge fund already worth 500 million and they can give you a return on your investment within one year, and in 5 they’ll be worth a few hundred BILLION. Oh, and if they fail the Fed will bail them out so there’s no risk.

Now, which one will you choose? Obviously, you’re going with the Option B: the guys who know how to make money already, can continue to make money, are rich already like you, and will most likely have a constant government safety net if they fail.

The guys from Option A are more than welcome to work the algorithms that make the Option B guys wealthy, but they don’t deserve your money.

The truth is, there are many reasons why NYC has a shitty technology startup scene, but the biggest one is that by comparison to Finance there just isn’t that much money in technology startups. When given the choice between a fine company like Etsy.com and a “small” hedge fund worth billions, investors will take the billions every single time.

Alright, So You Want To Move Anyway

Until the dominance of finance is completely destroyed you’d be wise to not move to NYC to run your business (with some exceptions I give below).

However, if you do, here’s some important things to watch out for:

There are a huge number of con-artists running shitty little startups. If it feels like they aren’t well funded and gonna take you for a ride then avoid them.
You will only get respect if you have an Ivy League degree or one from Stanford. A state university is laughed at, and you better start working on your sales voice because tech does not matter there.
NYC is a marketing town so looks are way more important than substance. Don’t demo tech, demo design.
Office space is expensive as shit in Manhattan, go to DUMBO with 10 buddies and share a massive warehouse loft.
You will not lure quants and banking programmers away from Banks. You will only get the bad ones who can’t hack it at their already pretty damn easy job. If you do they’ll expect to be paid tons of money you don’t have and insist on using fat bloated tech and won’t learn anything outside of their tiny little banking world.
Trying to bootstrap is stupid. It’s too expensive to live in NYC and nobody gives a shit about you so you have no support group.
Every person you talk to about financing will try to shove your tech into banking, marketing, publishing or government. Those four sectors of the economy run the town.
If you get into banking, marketing, publishing or government then do Java or .NET. DO NOT DO AN OPEN SOURCE LANGUAGE. Languages like Python and Ruby are increasing in use, but vast amounts of software is already written in Java or .NET so integration is way easier.
NO BANK, MARKETING FIRM, GOVERNMENT AGENCY, OR PUBLISHER WILL EVER PUT THEIR DATA ON YOUR FUCKING CLOUD SERVICE. God I hate telling people this but sorry, those four types of businesses are either deathly afraid of competitors, legally obligated to not give you their data, or just too damn old to even pull it off. Out of the four, publishing is your best bet.
Let me say that one more time: DO NOT SELL CLOUD TO THE BIG FOUR SECTORS. I’ve seen many a startup from the west coast fail because of that simple thing.
If you do try to sell to these types of organizations be prepared for incredibly long internal sales processes where the technology matters much less than your sales ability and how well it can integrate with their shit technology.
Given the above advice, you can probably guess the kind of business that would work in New York:

If you have an existing market product (learn the difference between “new market” and “existing market”)…
and you focus on banking, marketing, government or publishing…
and you can either demonstrate massive returns on investment or sell the shit out of it…
and you are willing to do inside sales with a solid marketing and sales team…
AND you are run by a slick looking Harvard or Yale MBA who’s male and 6’4" tall with a deep voice and pepper gray hair…
THEN, and only then, will your technology business take off in NYC.

If you don’t meet any of the above, and especially if your product is very “new market” or you need a long runway to bootstrap it, then avoid NYC like the plague. Move to San Francisco, Chile, Argentina, anywhere but NYC.

Then again if you do have those things you could just go into Finance and make billions instead of millions.

See how that works?

Why New York Is Awesome

The entire previous part of the article makes it seem like NYC sucks compared to say San Francisco or “The Valley”. My opinion though is that NYC is awesome for different reasons, it’s just the tech scene that sucks there. Nearly everything else about my life is better in NYC and I loved living there for five years. The people are great, the action is fantastic, and living there makes you tougher and smarter.

My only reason for leaving was the technology startup scene just wasn’t there. What little of it that did exist was completely dominated by Finance with no hope of getting recognized. It was either move out to the Valley and try my hand at interesting fun things or sit down and write an Enterprise Java Document Management system.

Take my warning, if you go out to NYC, admit to yourself it’s not for the tech. In fact, I think Fred Wilson would be way more successful selling NYC if he just said this:

“Geeks can get laid in NYC.”

Seriously, all that talk about some imaginary booming startup scene is bullshit.

The (Yet) Part

I added a (Yet) to the title of this post because the gravy train from Finance can’t last forever. Already people absolutely hate bankers and money men. If you have an MBA you can’t get spit on. There’s only so many times the Finance industry can pull a repeat of LTCM and AIG before people revolt. When that happens New York is absolutely screwed.

Manhattan has a serious addiction to Finance money. I bet the special NYC-only salary taxes from high paying finance jobs alone pave the roads and keep the schools going. Real Estate taxes on the buildings run half of New York State.

Finance is New York’s heroin and it can’t kick the habit no matter how bad it needs to.

I predict that either NYC is going to have to go cold turkey, or it’s just gonna die. Marketing is already tanking along with Publishing. If finance goes there won’t be any government sector to care about. The only thing that’s left is Fashion, and that’s fairly mobile. Without something ready to fill the void my favorite city will go belly up very quickly.

I see New York trying to kick the monkey. NYC Seed is one attempt. Fred Wilson trying to get startups to move out there is another. But they’re all just tokens with no real substance.

If you are dying to move to NYC to do your startup, then wait until NYC has kicked the Finance habit or you have a thriving business that can make it there.

Until then, you’ll just be wasting valuable runway on a city that really doesn’t give a damn about you and your tiny little millions (even if they should).
Curing Python’s Neglect

I’ve been working hard on the 0.9 release of Lamson and really enjoying myself while I do. Python is a great very complete and solid language with probably the best email handling capabilities I’ve ever seen.

After reading Jesse’s things he hates about Python I decided to do the same, but with a general theme. In general I really like Python, but if there was one thing I would change, it’s the culture of “Neglect” that permeates everything. No, not the neglect you think, but Hemispatial Neglect.

Hemispatial Neglect?

For those of you who refuse to read the article, neglect is where someone has a brain injury or defect that causes them to “neglect” one side of their body or visual field. It’s not that the person is blind in their right eye, as apparently everything functions and is being processed by the brain from that side. It is simply that they don’t cognitively comprehend that side, but, when this fact is pointed out to them they also don’t comprehend that they don’t comprehend. They’re just surprised that suddenly this event on the right side happened.

A good example is eating food. A normal person will eat everything in front of them, but a person with neglect will happily eat only the things on the left side of their body. They look at the right side, but they just don’t comprehend it. Then, you point out that they missed the whole right side and they look at it and go, “Oh! Where’d that food come from?” However, it’s not necessarily that they suddenly pointed their eyes at it, it’s that you pointed it out to them and made them focus on it with their left side.

Now for the creepy part. If you ask them why the didn’t see that, they can have any reaction from anger to giving a confused but totally plausible explanation. They honestly just don’t see that anything is wrong, but they also kind of know something is wrong so need to justify what just happened.

Demonstrating The Most Basic Neglect

To demonstrate this let’s look at Python’s list. Here’s how you add an element:

mystuff.append (mything)

That seems pretty reasonable. Now, if “append” is how you “append” something from the end of a list, how do you think you remove that particular item from the list? Yep, it’s remove

mystuff.remove (mything)

Now, what if you want to delete the item at index 4? Would you guess it’s this:

del mystuff[4]

When you first see this your brain (if you’re normal) goes, “WTF that’s not like the others.” However, if you have Neglect you would not only think this is totally normal, but wouldn’t even recognize it until someone pointed it out to you. Then when you are told about it, you’d make up excuses trying to explain why it is totally normal.

Python’s Neglect

This is exactly what happens in Python, and to a lesser degree other languages, but I’ve never seen it so bad as in Python. Everything from the easy_install tool not begin able to uninstall things to using del to delete an index but functions to append. You see it in the APIs, tools, and generally all over the Python world.

Here’s some of my favorite examples.

No easy_UNinstall

I jokingly made fun of this at PyCon one year, and people laughed, but then someone came up and told me the reason why is because of some bizarre complexities in setuptools about where things might be installed and how they’re loaded and whether you’re in a vitualenv or not and you might have a project that’s on a space ship that has a drag queen between you and the actual file that’s in UTF–8…

Honestly, if your install tool can’t uninstall because of the complexity of your packaging and module design, then your design is wrong. Redesign it so people can reliably uninstall. End of subject. It don’t matter why you can’t do this, you are missing an important feature everyone needs and all the justifications as to why it can’t be done are pointless.

rm -rf

For the longest time (at least until 2000 when I last looked) Python’s os.rmdir and friends refused to remove directory trees that had files in them. They would remove the directory if it had only directories in it but not files. You had to use os.walk to find everything and remove it. In fact, they claimed this was because they wanted to protect the programmer from themselves, and yet then they would put the code to do this in the help telling you that they crippled the feature on purpose to protect you.

Now they fixed it, but the way they did that is to create the new shutil even though everything in shutil has nothing to do with “shell” operations like running programs and everything to do with files. If you were looking for the rmtree now you wouldn’t find it where all the other file stuff is (os), but instead have to go to shutil, which makes no sense at all.

Time Conversion

Honestly every programming language makes time conversion a royal pain in the ass, but Python particularly makes this hard. It’s improved, but for the longest time you could get a string from a time object, but you couldn’t get a time object from a string. Even though this is basic POSIX functionality, Python just didn’t support it.

The explanation I was given at the time (this would be around 2000) was that I should buy the mxDateTime library and use it. Yes, that was the official answer.

I always wondered who the mxDateTime people had to blow to get Python to cripple time to the point that you needed to buy their stuff.

It’s improved, but it’s still a byzantine morass of API to do simple things with time in Python. Again though, this is universally a problem in programming languages, so I won’t place any blame on Python.

What I will blame Python for is the lack of even the most basic time conversion features that even C has. If all they did was give me the exact same POSIX C API I’d be happy. Instead, I got some half-assed library and some half-assed rationale about why this is a better way to do it.

email

Python’s email support is fantastic and very complete. I wouldn’t have been able to do Lamson in another language without writing a giant chunk of my own code just to do email. Thank you Python email, I love you.

However, it also suffers from some serious Neglect. There’s a ton of operations and APIs where you do one thing, and then the inverse is totally different for no reason.

Let’s take mailbox which is a great library if only because it supports maildir format natively and abstractly. It works this way:

Create an email message object with email.messagefromstring or email.messagefromfile. Remember those two.
Access the mail like it’s a dict. Awesome, the way it should be.
Alright, now to get the Body of the mail, you call get_payload, but that doesn’t work all the time.
Now, create a mailbox.Maildir object and you can just take these nice email object and shove them onto the queue.
Create another Maildir object and you can get, pop, remove, all the normal things you would expect from a queue.
Quiz time, if you get an email object from the Maildir, what do you get? Do you get a email message? NO! You get a MaildirMessage which is sort of like what you’d expect, except to read the body of the message you have to do msg.fp.read to read the file pointer.

Oh wait, it gets better. You can rewind this fp “file pointer” but it won’t go to the beginning of the original file, only to the body, so it’s not really the file pointer. Well what if you want the damn whole mail contents so you can do email.messagefromstring on it?

In the email module you simply do str (msg) and you get the whole thing in its original form as a string. Do you think that MaildirMessage supports this? Even worse, it supports it, but only returns the headers as a string. Yes, you end up having to do this:

str (msg) + “\n” + fp.read ()

to get the message back.

I really looked hard. All over the place in fact, and even asked smart folks on twitter and combed through google. Yes, this is how you have to do it, but the explanation I was given for why was absolutely bizarre.

If you go look at the API docs for MaildirMessage again you’ll see that it includes all sorts of operations for marking the messages status and disposition. The design decision was apparently that the object you get from a Maildir would be both the message and the operations you need to tell Maildir how to handle it.

This could have been much better designed, with either of these options:

Make str (msg) work like str (msg) in email and implement get_payload.
Have mailbox queues return email messages, and then have a second API call to get at any specific implementation’s meta-attribute modifications.
Return an object that’s not a message, but a combination of the meta-data manipulation and the message as an attribute.
Any of these options would be better than what is currently there, and this is basically what I’ve ended up implementing in Lamson.

API Documentation Generation

I need to do some documenation for the Lamson APIs, so I figured that PyDoc could generate them in HTML. This turned into a 2 hour yak shaving expedition into Python documentation tools which demonstrated that all of them just either don’t work, or seriously miss the basics of what a real programmer needs to generate documentation.

First off, I write comments in my code that serve as the documentation, and then I write full documents that show you how to use them. If you need to get started you read the documents, if you need to use it while you work you read the API docs.

Now, if I’m generating documentation from a Python API the entire process should be this:

doctool module html_directory

That’s it. Anything above that is cream. If your tool can’t do that then you fail. Miserably.

Yet, here’s what you have to do for Sphinx which is an insane amount of work for something that JavaDoc, POD, Doxygen, RubyDoc and nearly every other tool does better and easier.

PyDoc produces HTML. Sure, if you can call it that. It’s some bizarro nested colorized HTML that’s nearly impossible to read or use. PyDoc is basically this old as hell doc tool that (AFAIK) can’t take a template to modify the resulting output.

I thought, well maybe I could get Pygments to do it. Pygments will take a source file, and it will output a source highlighted version. That might be good. Oh, but pygemntize will only output the body to a file, and then the style has to be put into a separate file, and then you have to wrap the output file yourself with your own HTML header. Pygments is awesome for doing color output, for just dumping a directory of source to HTML files it is useless.

Apydia looked promising. At least it produced something alright, could be more compact but that’s fine. Then you run it and realize it forces you to explicitly indicate every module you want, even the submodules (despite what the docs say). When I run it, it blows up on a Genshi exception error. Great. Awesome.

The list goes on, and continues to demonstrate Python’s Neglect for the simple reason that it is the only popular modern language that doesn’t have a decent API document generation tool. Yes, they have documentation tools, and yes they can generate some HTML from an API, but it’s all just not quite there. It’s simply missing the simple feature of “take module, make html, put on website”.

Curing The Neglect

There’s many more places where this kind of neglect is found, but these days I just accept it and move on unless I seriously get pissed off. The last tool I did this to was argparse and optparse which I replaced with a much nicer system in Lamson.

If I had the time I would try to fix this stuff, but I realize that none of this will be fixed until there’s a cultural shift in Python away from this habit of Neglect. There has to be a committed change in the way Python APIs are designed so that for every operation there is an inverse, or a damn good explanation as to why there is no inverse.

If there’s a put, there’s a get. If there’s an add there’s a delete. If I put a string in, I get a string out. If I can generate a time string, I can parse a time string. If there’s an install, there’s an uninstall.

No excuses about how that doesn’t fit your design. If your design is such that you can’t implement get when you have put then your design is flawed. Start over. Don’t be weird or different, just be boring and give me my uninstall.

Of course Python isn’t the only language with this problem, it’s kind of a programmer affliction. I just see this culture of Neglect much more commonly in Python.
The Freehacker’s Union

This rant is about an idea I have for a group of geeks who fight to keep the art of hacking and invention alive. I want to call it The Freehacker’s Union. I want it to be against business, against the coopting and destruction of geek culture, and for preserving hacking and invention as methods of personal artistic expression.

The idea is still forming, so this is the story of how it came about.

Business Is Killing The Art Of The Hack

My realization of this started fairly innocently, ever since my job as Vice President of I.T. at Bear Stearns evaporated overnight. Don’t worry, being a VP at Bear didn’t mean jack shit. It meant only that I got a fat severance package that lets me work on one of my ideas, and I decided to go for it. I’m going to create simple, durable, and open programmable hardware for my guitar. I’m not really interested in making it into a business, but if that happens that’s cool. I’m more interested in expressing myself in a new way that involves the intersection of my technical and artistic abilities.

This requires practicing guitar more, working on a few little software projects, and doing a serious amount of electronics hacking. I’ve actually built a huge number of circuits, read tons of books and learned how to program a PIC basic stamp. I fucking love this shit. After years of hacking on web servers, it’s nice to just get down and dirty again.

I actually like doing this stuff so much that I’m going to start recording videos of the things I build and other stuff and put them online for people to look through. Right now I’m working on a cool project that will be a programmable true bypass effects router board. It’s pretty snazzy how it all works, but I kind of need to save the description of it for a little later.

The videos and blog entries about electronics here will mostly be for me to record the adventure as a series of advanced lab notes. I do some amount of self-education on the subject every day so I really do need to document it somehow.

One thing I found through doing all this hardware hacking is that people who wield a soldering iron in NYC are kind of secretive. I mean, they’re nice enough, but they really hold their secrets close to their chest. Take sourcing parts as an example. I would go to meetings where people showed off cool projects they made, and ask them where they get their parts. They would just evade the question, or tell me “digikey”, which is bullshit because I saw some Radio Shack shit in their gear.

I had to do my own research and found that, no, these guys get some of their shit from the NYU Computer Store on 242 Greene St near Washington Square Park. It’s obvious since everyone in NYC uses Arduinos and this store has most of the parts I’ve seen them use. That store has an entire section that’s dedicated to hardware hacking gear, including parts, kits, tons of Arduino components, full stamps, everything. It’s even got books by Tom Igoe about making physical computing devices, something that all the guys I talked to obviously read.

There’s also several very good Radio Shacks in the city that have a large array of parts if you need them in a hurry. My favorite is the one on 14th just west of Union Square. Radio Shack isn’t what it used to be, but many of them have a big cabinet full of OK parts that you can at least use to get started with, especially if you have no idea what anything is initially. The people who work there are totally clueless, so bring a friend who knows better (if you can find one willing to help that is).

I however am focusing on the PIC line of processors, and probably won’t do much with the Arduino. I’m not sure why people like the Arduino, but god damn is that an expensive platform for very little capability. The PIC is a fun little platform and does most of the stuff I need, plus it’s dirt cheap and easy to use with a ton of free complete books available for download from Parallax that cover all sorts of great topics. I’m serious, just about every book they sell is available free as a PDF.

Another thing I’ve found is that trying to learn electronics is very frustrating simply due to the poor quality of the books available. Electrical engineers are great at describing a component, but not at explaining how you use it for something. I swear I read 10 books on transistors before I finally found one from Parallax that just simply told me how to use one with their basic stamp. Also, the cool Radio Shack kits by Forrest M. Mims III are fantastic because he painstakingly goes through every step so you don’t get lost.

You have to understand the theory of electronics of course, but without any practical examples the theory is totally useless. In the same way having a book of nothing but examples is also useless since the theory helps with creating new things not found in the examples. What the EE books need is a good mix of both theory, application, and why something is done. You wouldn’t believe how many times I’d whip through a book, see some weird thing in a circuit like an inverted LED on a reed relay, and wonder, “WTF is that for?”

Only days later in some other book do I find out that, yes, that LED is crucial when using a relay because it absorbs the stray inductive current the relay generates as it collapses. Nice, glad to know that. (Of course, maybe they should put fucking diodes in all relays.)

Otherwise, this adventure in electronics is incredibly fun, and mixing it with my music practice is a blast. It’s a great way to mix up art, performance, and geek exploration into one big mash.

Yet, during this time something has been missing. I just can’t seem to find anyone else in the city really doing this kind of thing. I tell people this and they mention NYC Resistor but those guys are more of a business selling classes than an actual hackspace or club. I tried asking them in IRC how to join or get into the space, and they were kind of snooty and vague.

“This Town Needs An Enema”

The hacker scene in New York sucks. With a few exceptions, I’m finding that every geek gathering is full of asshole MBAs, groupies, and their wannabes. It’s fucking depressing, and makes me feel like I’m the last of a dying breed.

I realized this in stages over the last couple of months. I asked some of my more connected “friends” where they go to meet nerds. Silence. They apparently don’t go to any kind of meetups or anything, and if they did go they weren’t telling. I found out that VCs go to these parties looking for the next dumbfuck web site they can waste someone else’s money on, so the people I asked consider this a limited resource not to be shared.

I tried a few user groups, but there’s barely anyone doing anything truly interesting. I really do enjoy the people who take the time to go to a user group for their favorite tech, but at the same time I feel like they’re just there to escape their jobs. That’s sad because I run into people who say, “(sigh) I have to do Rails”, even at the Python groups. The Python group has had two months of meetings about fucking performance tuning. I love those guys, but holy baby jesus can we just move off of cython already? I hear reports that even the iPhone and Cocoa user group is lame. I mean, that group should be going ape shit right now.

The few user groups in NYC have to beg for space. I posed the idea that the Python group meet twice a month like the Ruby group, and they said they can’t find space. This is classic tragedy of the commons. All these fucking companies in this city making insane cash off Ruby and Python and the user groups training their employees have to beg for space? You’d think Google would kick in space for a damn Python meeting once a month.

Then I stumbled on this IgniteNYC event which had a soldering competition. Surely that would bring out the nerds. Nope. If you read that link, you should find this gem:

“They’ll do a tweetup and say ‘Let’s go to the castle’”.
What?! Don’t fuck up my geek terms you moron! Die! Die die die die! Fucking arrggghhh! Who let idiots who say things like that into my world? I read that and I didn’t know whether to cry or strangle a kitten. Then a friend sent me a LOLcat so I had to just cry.

IgniteNYC was pathetic. There were more eye candy bimbos there than at the fucking Bunny Ranch and more business douchebags than at the fucking Bunny Ranch on two-for-one night. It wasn’t a geek event at all. It was an event where the newly minted founders could find a cum dump to fuck that night, and the business idiots could find a new “techie” to exploit. It made me sick.

Then I went to another event at SparkSpace, which is a fairly nice coworking place in midtown. I walked in the door and some guy (one of the hosts I guess) asked what I do. I said, “Well, I’m a programmer but I…” Then he cut me off and said, “Oh! Everyone’s always looking for techies. I’m sure you can find some great ideas here to work on.”

Yes, because I don’t have any of my own ideas. No, you see I’m a fucking nerd because I code. Never mind that I’ve traveled the world, survived horrible events, built myself up from nothing learning to fight, love, pray, and survive despite numerous obstacles that would make this little maggot piss his fucking pants.

I fucking code so I’m not a man anymore.

You see people, the alpha males have business degrees. They can be fat and pasty, pretty boy douchebags, or even ugly serial killers, but if they have an MBA from a 6 month “executive program” then they’re ALPHA. They have the ideas. They have the balls. They’re full of testosterone. Now me, I learned to actually do something with my brain besides take people’s money, which means I’m not a real man. My ideas don’t mean anything and I’m just supposed to let the adults talk. I’m BETA, and only some shit fuck rich boy (or wannabe rich boy) with his fucking pop-up collar and cheap suit can truly lead.

Then it hit me, it’s the business that’s killing tech in this city. The business of technology in New York values douchebag asswipes and “idea guys” over the real people who built this world. Their ideas are shit, but because they have an MBA from Columbia (they didn’t do much to earn) they are listened to and valuable. Me and the other hackers are just tools, cogs, and slave labor designed to be subservient to a real man’s passions.

The problem is, because none of these dicks do anything they don’t know what’s a real technically challenging innovation. They would rather try to make a little bit of money making a slightly better version of whatever everyone else is making. They want the lottery tickets and the fast payout where they take all the fucking money and trade the geeks over to Google or Microsoft like some fucking slave exchange.

Since when did selling a company mean that the buyer gets the employees by default? When the only thing that was really valuable in many of these acquisitions was the employees. The techies. The geeks. The nerds. Not the asshole biz fuck nut who snorts coke and thinks he’s so important. The real value in a company with an idea guy’s turd of a product is the smart geeks who put the polish on it.

The business is killing the spirit and passion geeks have for making the things that make this world. By pushing the Alpha Biz Guy’s (ABG) myopic view of what’s cool we are snuffing out what brought guys like me to technology and inventing in the first place: The awesome hack.

I want my awesome hack back dammit.

The Freehacker’s Union

Bear Stearns was a 400 billion dollar company that survived the Great Depression, many recessions, and several wars. In the end, it was killed by two idiots betting heavily on bad ideas, and a few people playing 1.7 million dollars in puts against the company. It was business guys, not geeks that destroyed that company. They did it back in the last dot-com boom too. Enron, Sarbanes-Oxley, and the dot-com bust is all the MBA’s fault.

The impact of Bear Stearn’s death is staggering. 15,000 people lost their jobs, pensions, careers, and friends overnight. The impact to the economy is only now being felt. The practice of “naked short selling” that caused Bear’s death will be regulated for a short time by the SEC just to protect companies like Bear. The FED had to open special lines of credit to other banks to keep them floating. Taxpayers will have to shell out trillions of dollars to keep things stable.

All because of two dumbfuck business guys betting on ninjas No Income, No Jobs, no Assets.

I fucking hate the Alpha Business Guy right now. I need a hack night that’s just for geeks. Hell, what I really need is a hack night that’s all about the art of the awesome hack. I want something that is so completely anti-business that attending this group could get you fired. Well, maybe not that bad but I sure as hell want business guys to stay as far away from my fucking art as possible.

What I want to create is something that’s been rolling in my head for a while called The Freehacker’s Union. A group who’s goal is to:

“Preserve hacking and invention as methods of personal artistic expression.”
I want the rules of The Freehacker’s Union to be:

If it’s art, wires, or code you can bring it. This will be our triad: art/wires/code. Remember it.
NO FUCKING BUSINESS ASSHOLES This isn’t your personal fucking recruiting station. Take your “game changing” ideas and fuck the hell off.
If you can’t sling at least one of the three in the A/W/C triad then you can’t come. No exceptions.
Everyone who attends has to eventually show something. If it’s your first night, you have to present something. It can be anything, but you gotta show that you belong. If you can’t then you can’t come back until you can. For those who absolutely can’t talk in front of people, you can get someone to show your stuff on your behalf.
No girlfriends or boyfriends unless they’re hardcore too. Keep your fucking groupies at home.
Organized using simple software that’s open. No special hidden jabber servers, no yahoo groups, no fucking evite or someone’s favorite latest startup website. Just a simple mailing list, a website anyone can manage, and maybe a channel on IRC.
Frequent meetings at a regular time and spot. I like twice a month, but hell if people can handle more then I want to do it.
Clear guidelines on how to become a member, including the benefits and responsibilities.
Other than that, I’m open to suggestions. I’m going to be doing more writing on this subject, and coming up with ideas with friends, and then I’ll announce our first meeting. If you have thoughts, or you want to attend, then let me know.

If you’re an Alpha Biz Guy then fuck off. I don’t want to hear about how you can kick my ass and how I’m never going to get hired again.

I don’t give a fuck about you, I just want to hack and you’re fucking that up for me.

Let the games begin!
x=Control, y=Responsibility: A Simple Principle For Managing Smarties

Someone once asked me if I could give one bit of advice to an aspiring manager what would it be. At first I said, “Go kill yourself.” But then I remembered how hard it was for me at first leading a platoon at 18 in Army basic training. Instead, this is the one piece of advice I’d like to give every aspiring manager:

Control must be correlated with responsibility.

By “control” I mean the authority to make decisions. The person in a situation making the decisions is the one in control, not the person doing the work. Many managers and team leads wrongfully believe that since they allow the team to do the work that the team is in control and therefore responsible. If management decides the tools, working arrangements, room temperature, desk quality, chairs, budget, or anything about their environment then management is in control.

By responsibility I mean the rewards or punishments for the outcomes. People will gladly accept responsibility when there are rewards to dish out, but the second things go wrong they start shifting the responsibility elsewhere. The person who gets punished when it goes bad or rewarded when it goes good is the one responsible. I’m repeating this because it’s very important for when you start to shift responsibility around the team to correct deficiencies.

Where things go wrong in management is when control is given to one person yet responsibility is put on someone else entirely. When this happens the people in control tend to do whatever they want and the person who’s responsible is miserable, quits, goes insane, or stops caring. This causes most of the conflicts in your organization and once you make this mistake it’s difficult to correct it.

However, when control is correlated with the person responsible many of the conflicts go away. This can be done by either moving control over to the person who is held accountable, or simply make the people in charge accountable for their actions.

It Starts With You

As the leader you have to lead by example and demonstrate that you are ultimately responsible. Managers sit behind the team and tell them what to do while a leader gets out in front and says, “Follow me if you want to live!” Even though you give the team control and make them responsible for the outcome, it’s really your fault if things go wrong. Make this clear to them and demonstrate it at times. Do this and when they screw up they’ll be more inclined to accept responsibility themselves.

Once you’re established as the leader and they know that you’ll take the rap for bad decisions (shielding them from your bosses) you can start to restructure who’s in control and responsible on the team. It won’t be easy because you’ll be taking control away from people who don’t deserve it, or potentially making people responsible for their actions. Nobody really likes this but in the end it’ll make for a healthier situation since the new setup will give people a feeling of ownership.

There’s a few other things you need to really make this work. First, make your expectations clear and potentially measurable so that they know what you want and you can make sure it’s getting done. Next, I try to follow the “trust but verify” model. I trust them to do what they were hired to do, but I verify that what I’m being told is true. Finally, I never dictate how things are done, but instead focus on the results of the process. If I have to get involved in how something is done then I make a point of sitting down, pairing with the developer who’s in control, and doing it with them.

Story Time

Here’s a few little stories and examples that should help you understand

the concept. It’s pretty simple but having examples usually helps to clarify things further. Anyway, they’re funny and should be familiar to everyone.

Example: BOFH

My favorite example of a disconnect in control and responsibility is not from a manager but actually from a system administrator. This guy was able to

convince management that the developers were responsible for huge amounts of downtime. He did this without any proof and managed to gain control of all the machines in order to lock us out. In fact, we rebelled and were able to show that this asshole was the cause of all the down time but management wouldn’t listen.

So BOFH locked all the machines down and wouldn’t let any developers in without permission from him. He controlled everything from permissions on files to what servers ran where to what our logins would be on each machine. However, when a server when down, someone breached the machine, a log file overflowed, or any other number of problems BOFH would blame us and we’d have to work weekends to fix the problem.

The sad thing is in every case we’d demonstrate that the BOFH was to blame. Great example is I spent a Sunday and Monday tracking down why our server didn’t work to find out it was because he wasn’t rotating the Apache logs. The logs grew to 2G in size and Linux choked on the file so Apache aborted the connection. The BOFH however managed to convince management that this was all our fault even though he controlled everything on these machines.

Management screwed up because they put this guy in control but didn’t make him responsible for the results. They let him blame the developers even though none of them could get onto the machines to fix them without his permission. What was even worse is management ignored all the information we gave them and our constant complaints because once they gave BOFH full control he used it to blackmail them into keeping his job.

Now, if management had instead made BOFH responsible for the uptime of the machines and measured it the results would have been different. I’ve actually implemented this change at a few organizations and immediately the BOFH starts handing out passwords to people and getting them involved in the planning process. The BOFH sets up monitoring to prove his uptime metrics to get his bonus. He wears a pager constantly and wants to be a part of the deployment planning of the team.

In other situations I’ve had to take control away from a BOFH and give it to the developers because he refused to take responsibility. This was at a different company but the guy would spend hours deploying applications that took the development team five minutes and one command (yay for capistrano! yay). The guy implemented draconian firewalls, ridiculous security restrictions, and didn’t listen when we told him how the application should be deployed.

When things went wrong he blamed us so we had to move development off-site and do it all ourselves in order to get the control we needed. We took responsibility and suddenly our uptimes improved, our deployment was a snap and working with consultants became a breeze. The guy eventually quit but it was probably a good thing. He once told me, “You are a good developer but you know nothing about deployment.” It was a rails project using Mongrel. Yeah, I know nothing.

Example: Strippers And Steaks

From the management side my favorite example is what I call the Strippers And Steaks Maneuver. It usually goes something like this:

A sales guy takes your manager out for a huge steak dinner and to a strip joint.
Based on this (and usually half drunk) the manager signs a deal to buy their crap.
The next day the PHB walks in hungover and announces that you’ll start using this new thing he just bought.
Everyone then spends the next week working this rotten thumb of a product into their usual tool set and process only to find out it is total junk.
But, management has already spent millions of dollars on it so you’re forced to use it.
The other way this goes is when some idiot manager reads an article in Fast Company or CIO magazine talking about a new process or tool that worked at one place on one project nobody cares about.

This is a classic control and responsibility disconnect. The manager takes control of the tools and processes being used, but being uninformed makes bad decisions. However, the manager never accepts responsibility when the tool turns out to be a dud because, well, “It worked for NASA!”. Since the developers can’t make the tool work obviously they are idiots. Can’t be that the tool just sucks.

The correct way to do this is to never make a tool purchase decision without making the sales guy pitch to your most vocal developer and without letting the developer try the product. Also never make someone use a tool unless you’re willing to admit it isn’t good and back out. I’ve actually taken the stance that if the sales guy can’t setup a live demo involving my team in less than a day then there’s no way the product is viable. The rationale for this is that if the company that wrote the tool can’t get 10 engineers to configure it in a day, then how is my untrained team going to do it?

Warnings

My first warning is if you try this and it doesn’t work then don’t keep doing it. Geeks are notorious for getting a process and using it despite all evidence proving the process invalid. Take the time to analyze why it’s failing and then adjust things to fit your situation. This is just a general rule I’ve used that worked, but I haven’t followed it blindly myself.

My second warning is I don’t advocate firing people unless they are incredibly incompetent and can’t be trained. I’ve been able to train plenty of people so usually the only people I’ve had to fire were the arrogant ones that couldn’t learn because of their egos. In fact, I haven’t fired people but instead moved them to a different team where they’ll fit in.

Finally, this one rule won’t make you a competent manager by itself. You’ll need to read up on tons of other things like how to measure processes, motivating people, morale, hell even just basic time management. I’ve read so many of these books that there’s nothing new out there. Just keep looking for little nuggets of information, trying stuff slowly until you find what works for you.

And that’s the best advice I could give for an aspiring manager. Good luck.
Fortune Favors Big Turds

Donald Norman and Joel Spolsky both had their say on how you can’t sell simple software. It’s my turn to say they’re wrong because they adopt an obnoxiously true-or-false stance based on horrible examples. The situation they’re discussing is too complex to fit into a single blog post and I’m not gonna try to convince you that complexity or simplicity is better. I believe you can do both simultaneously.

I’ll also explain why their observation actually does apply in open source software, but from a completely different perspective. See, I’m gonna lure you in by ranting about Joel and how he uses his piece of shit Wasabi to build a single nasty ass bug tracking product, and then waylay you with what I think.

Man I HATE Boolean Arguments

First off, before I even start talking about these guys can I please get someone to thrash the next programmer who breaks an argument down into only two possible options?

Please? Just smash his legs or something. I feel nausea being near people who use if-statements all day long and think that the whole world can be boiled down into true or false with no options. You damn robots! Wake up and start trying to flex your mind around undefinable concepts for once in your life.

Look, economics and sociology are incredibly difficult to understand. What sells as a product and whether it’s simple or complex are probably completely unmeasurable. There’s cultural differences, class differences, timing, presentation issues, the works. It’s ridiculous to say, “Damn! They like SUVs here! Those are complex! MY GOD KOREANS LOVE COMPLEXITY 80/20! 80/20! You wrong biatch! BUY FogBugz!”

Ever seen the Korean alphabet? It’s called Hangul and it is probably the most advanced alphabet humans have right now while also being simpler than most of them at the same time. It can be stacked like Chinese characters, but it’s also built more like ours with an ability to construct unusual vowel sounds. Get this, it was invented in about 1443 AD and even mimicks the way the mouth is constructed. That’s right, the characters actually look like how the mouth, jaw, and glottis form to make the sound. It’s brilliant and a gorgeous piece of work that demonstrates how something simple can also have incredible complexity lurking under the surface.

Did you know that Hangul is so good at mimicking other language constructs that some anthropologists want to use it to record near-extinct languages? It takes an average person about 3 days to learn it, whether they speak Korean or not, and they can use it to write down their own language even if it’s completely different from Korean. It’s that universal. Imagine being able to get native speakers of dying languages to actually write down how their language is pronounced. Now that’s power.

I’ll give you a great example. I was walking around Seoul one day and drinking this soda call “Pocari Sweat” (said so in English on the side). Yeah, it says it’s got sweat in it but damn it was good. I turn to a Korean woman, point at the Hangul on the side of the can, and ask in bad Korean, “Can you say this?” She reads each character of Hangul as:

“poh car ee sw et”

That’s right, the English on the can was mimicked nearly exactly by the Hangul and it made no sense to her either. But, she could read it and we both said the same exact verbal noises even though we read different alphabets. She thought it was funny too.

Now, tell me that a culture which created the most advanced and yet simple of alphabets (at a time when everyone used the Chinese characters) somehow hates simplicity. Go ahead, I’ll stop laughing when you finish saying it. You’re wrong.

This is the first flaw in both Joel’s and Don’s arguments. They’ve made this boolean argument where all software must be simple or complex. What they’ve missed out on is that some systems can be both at the same time, just like Hangul. Hangul is incredibly simple and easily learned by people even if they aren’t Korean. Even the Roman alphabet we use can’t pull that off. Greek’s not even close. Latin blows for this too. All these alphabets are just missing the necessary building blocks to encode all the sounds a human can make.

With one simple set of characters based on human physiological speech principles, the Koreans created a system that’s capable enough to do what no other alphabet can pull off as easily. Its capabilies are complex, but its structure and design are simple.

Oh, but no, software must be complex or simple. No in-between, nuanced analysis or multi-faceted discussion. Nope, just two dudes blabbing about a dumb argument based on a flawed view of another culture. This is why all the big flame wars go on forever. Both sides setup obnoxious boolean arguments and argue about their points, but usually they don’t realize that both of them are right or that there can be tertiary perspectives and options they haven’t considered.

Only 2 Generations of Car Owners

You know why Japan is considering changing its constitution to allow them to fight a war? You see, Japan’s neighbors don’t like Japan too much. There’s this nasty business about World War II and some things Japan has never apologized for properly. Now that North Korea has nukes the Japanese are getting their panties in a bunch. I would too. That dude Kim’s quite crazy.

When the Japanese left Korea they were getting beat back by MacArthur who landed in Inchon and started kicking the shit out of them. Koreans call us “Miguks” (“beautiful nation”) because when we showed up they were being decimated by the Japanese. We saved them at a time when nobody else could or would. This is and our continued occupation is the source of most Korean’s love/hate relationship with us. They love us for saving them, but hate us for staying so long.

Apparently the Japanese left Korea and took an estimated 26,000 girls as “comfort women”, took every tree in the country, and possibly a national treasure or ten. Take a look at pictures from right after the Korean liberation. There’s barely any trees, and the few that remain are damaged soon to die. There’s only a few old growth trees in South Korea because of this.

The Japanese destroyed that country and left nothing behind. Then a civil war broke out and things got even worse. It took a good many years after the establishment of the DMZ before South Koreans even had enough infrastructure to have factories. Even then they had to make roads, military equipment, and other things to support building the military to defend themselves.

Forget about SUVs, washing machines, televisions, or any of the crap Don saw on his trip. They needed to rebuild houses, farming equipment, rifles, and other basic survival goods.

What Don witnessed is the second and third generation of Koreans after WWII experiencing prosperity and novelty. Most of their parents and many of them haven’t had these things before. They don’t know what’s crap and what’s good since they haven’t had much experience with it. Ever been to the grand opening of a Super Walmart? Ok, now you’re getting the idea.

This isn’t an insult on Korea, it’s a testament to how kick ass they are. They came up from near destruction to build a massive powerhouse in the region. Koreans have enough clout in Asia to demand that the World Cup be done fairly between them and Japan. That’s some serious muscle.

However, despite shipping their cars all over the world, until recently Korea had one of the highest vehicular death rates in the world. They make a ridiculous number of cars, but the populace has only been around cars about 50 years. Koreans haven’t acquired as sophisticated a taste yet because it’s all new to them. Everything is cool.

South Korea is also an incredibly complex country, but obviously that wasn’t apparent to Don. Don never asked about reunification, Dok Island, or the Kwangju massacre because that’s not discussed by Koreans unless you ask them. Don never wandered the hills near the old Hwarang schools to see all the austere Buddhist sculptures carved into the mountains. I did and I barely know jack about Korea. How does Don know they only like complex electronics from one or two products in some electronics market?

If you want a taste of what Korea will be like very soon check what this guy Ahn Sang-soo is doing with Hangul and Korean style. Simple, elegant, stylish. Some of his stuff is changing how even the west perceives typography and design. Hell, he’s got the whole country covering one eye for no other reason than he thinks it’s cool. He’s the first person to successfully break Hangul out of its “box prison” as he calls it.

This new Korean sense of self and style is the market to hit with your software and products, not the crap people currently buy. What they’re buying now is novelty, as their tastes mature they’ll start to look for stylish products that fit in with the culture around them currently. They’ll pay a massive premium for things that feel Korean, or hit that cultural chord that guys like Ahn Sang-soo are playing.

Sure there will be some mixing of new and old, that’s normal, but it won’t be shitty SUVs and washers with every feature you can imagine in plain site. It’ll be simple but powerful like the rest of Korean culture.

Shove 80 Up Your Ass And Spin On The 20

I am getting tired of Joel blabbing about his one trick pony FogBugz. I’ve used it and it’s utter total garbage. It’s pain level just happens to be between Trac and a prostate exam from Dr. Edward Scissorhands so some corporations buy it. What’s even more amazing is that he actually manages to sell what is basically a crappy todo list to companies and make some money on it.

Until Joel can learn enough statistics to conduct a usability study that does a task analysis comparing FogBugz to Trac for developers he can shove it. You see, FogBugz sells because it screws developers for the sake of keeping managers and bean counters happy. It’s like every lame ass tool sold to management. Rather than make a time tracking or defect tracking system that developers can use they make a product that managers love. Slap a few fancy charts and reports nobody will use, present it to an accountant or desperate manager, and sold to the man in the funny hat.

Let’s not stop with just that in our demands of Joel. I’d also like to request that he stop using The Pareto Principle in software discussions until there’s some solid scientific experimental evidence backing it at all. When I say “scientific experimental evidence” I don’t mean self-help books disguised as management guides that desperate managers like Joel Spolsky read. I mean real work from a real sociologist with a solid repeatable scientific methodology in an established experimental design form that validates The Pareto Principle is even close to possibly legit.

Here’s why: it was popularized by this business guy named Joseph M. Juran based on an observation by an Italian exiled noble Vilfredo Pareto who made the observation about the distribution of wealth in 1906.

That’s right, Joel is slinging 80/20 like it’s truth from Cthulhu when actually it’s completely made up, 100 years old, created by an aristocrat to talk about the poor he didn’t like, and has no real scientific backing whatsoever. It’s not a fucking rule it’s a lame ass boolean logic analysis coked out managers use to justify all sorts of stupid decisions.

Using 80/20 is again another boolean algebra argument that programmers love. Everything is either “80/20” which means “simple” or it’s “complex”. I’m guilty of it myself in the past but no more! I banish 80/20 from my vocabulary as just more unfounded semi-religious bullshit keeping people in the software industry stupid. Enough!

Gotta Rape That One-Trick Pony

I’m gonna make a brash statement here and say that Mongrel out sells FogBugz by huge margins. First we’ve got Mongrel’s download stats putting the download count at around 93,000 give or take a thousand or so since some folks download in weird ways. A quick survey amongst the main hosting providers using Mongrel puts the number of sites being run by Mongrel into the thousands. Just my quick IRC survey with the big adopters says about 3000 to 4000 domains. That also doesn’t include all the people who use it for their development platform every day.

The number of transactions Mongrel is processing right now is down right staggering when compared with FogBugz. I know I only used FogBugz when I had to use it and that was only to keep a manager happy because he had bought it. Most people I talk to are in the same boat with that product, but people who use Mongrel generally love Mongrel…even if they hate me.

Add to this the fact that Mongrel currently powers Ruby on Rails, Nitro, IOWA, Camping, merb, a few other little frameworks, several one-off custom servers for things like file uploads and you’ve got a power house. What’s even more impressive is I had next to no hand in getting these frameworks and projects operational other than giving advice and writing documentation. Most folks took the software and just ran with it, only asking me questions if they got stuck.

It’s possible that FogBugz does way better than this. I doubt it based on what every developer who uses it says. I would laugh at any claims of sales over maybe 2000 installed paying customers. I’m seriously doubting downloads are over 93k/year. If they have over that then Joel needs to fire his sales team because that’s a conversion rate that’s less than 2% of downloads.

However, the real comparison comes from the size of the two software systems and what people are using them for in the real world. Mongrel powers entire companies who base their business on it as a core component. These are hosting providers, major well funded web sites, government agencies, and universities. If FogBugz went down or had a bug then most people would just keep doing their work. If Mongrel has a major bug people lose lots and lots of money very quickly.

What’s amazing though (even to myself) is that Mongrel’s core feature doing all the work is only about 2500 lines of C, Ruby, and Ragel code. The Ragel code is about 129 lines long, the majority of the code is Ruby with C as a close second. This simple bunch of code somehow ends up being incredibly malleable with people writing custom servers, embedding it in Amarok, basing new frameworks on it, and deploying heavy weight applications with it that I never anticipated.

Mongrel even runs fairly unaltered on Win32, any Unix derivative, AIX, Solaris, and probably systems never reported by users. I’ve heard rumors of people trying to get Mongrel running on cellphones. That rocks.

Joel admits to writing FogBugz in a very advanced, functional-programming dialect of Basic with closures and lambdas in order to make it work. This weird language compiles down to an insane number of other languages just so Joel can have the application run on any operating system. It’s incredibly complex, but it doesn’t have to be since, well, there’s other better bug trackers in use today which don’t require any of this. There’s not much competitive advantage even because Joel admits it’s not used on anything else at the company.

This is where Joel’s writing about software complexity irks me to no end. He’s the master of being for both sides of the boolean argument as long as that draws a crowd. When you critically take a look at his claims about how great his software and his team are you start to see that he’s full of crap. Nobody I know thinks FogBugz is any good. It’s junk. He admits it’s complex and there’s obvious single-quote escaping bugs on the PHP side. The grain of salt I take with Joel’s writing could desiccate a water buffalo.

Mongrel however provides an example of a simple piece of software having hidden complex usages and power. I didn’t start out intending it to run on everything and power all the Ruby web applications out there. It was just so simple and easy to use without a loss of power that people could take it and mold it to their needs. Because of this simplicity people can understand it in about a day, and with that understanding comes new uses.

That means people use Mongrel not only as-is out of the box, but also extend it for their own devious plans. Of the people I know who have FogBugz, none of them extend it farther than adding their projects through its painful interface. Even if they wanted to they probably can’t because they don’t have Wasabi Powers™ like Joel. More people “buy” and enjoy Mongrel than FogBugz. Everyone I know who uses FogBugz hates it. It’s designed for managers not developers. Most of the people who use Mongrel love it, since it’s not designed for Managers but rather for developers by a developer.

I’m proud of Mongrel, but don’t let me fool you into thinking I believe it’s perfect. Far from it since there’s a few ugly pieces that are required to work around Ruby’s limitations. But I’ll stand by my comment that it’s a way better piece of work and craftsmanship than FogBugz.

One more thing. How can a functional BASIC be advanced? C’mon. That’s like Faye Dunaway getting a boob job to make her tits look 20 while her face looks 55. Just wrong man. Wrong. Let BASIC die please.

Open Source Also Backs Complexity

Now, I will admit that Mongrel is a fluke in the open source world. Joel and Don are right that people love complex software, programmers especially. I despise it and truly think that my open source efforts are meant to be demonstrations of how a simple system can be insanely effective. I’m trying my best to change the way programmers think about software away from “complex vs. simple” to an understanding of the middle way of Shibumi. I’m trying but it’s hard which is probably why I get a kick out of it.

Open source software however tends to promote complex and difficult to use software in a different way. If open source software is difficult to use then you can give it away but still:

make a killing supporting it
write books for it
get contracting gigs setting it up
get gigs fixing the source for new purposes, and
even sell commercial support licenses so people don’t panick over how shitty the code and documentation has become.
Commercial software can’t seem to do this for very long, but open source can hold this stance for decades. Take a look at Apache as the prime example. I think Apache’s nasty ass configuration file format has employed hundreds of thousands of system administrators by itself. The bizarre ways that modules are configured probably amounts to 1/3 the population of Estonia alone.

Open source software as a business promotes producing complex and crappy software in an effort to boost the potential for consulting gigs. I’ve even overheard people in the open source biz world intentionally design something with tons of complexity in order to boost consulting.

Why? Because guys like Joel and Don scream out to programmers that it’s alright to make complex buggy crap that’s difficult to use. “Complexity sells! Fuck the art let’s make cash.” Well, if that’s how you want it then get ready for the Thomas Kincaid of programming to come. Slap a dab here and move that sucker on out.

How I Know About Korea

I was stationed in Korea for a 1.5 years as a soldier in the US Army and made a determined effort to explore every inch of Korea I could. I even spent a month in Thailand rather than fly back to the US. I also studied Japanese and Korean history as a hobby and martial arts for years.

While I don’t even begin to think I know anything about Koreans, I sure as hell know a lot more than Don or Joel. I’ve been there and ate nearly every damn food they make while trying to absorb every bit of their culture I could. I studied their religions, their history, and made an effort.

You see, I found an interesting culture full of contradictions and struggling to combine its past with its future and desperately wanted to learn about them. Don saw an SUV and thought he knew some shit. He doesn’t, but if he’d taken the time to figure out why this might be rather than believing his own thoughts he might have learned something.

I think the future of software is in things designed like the Korean alphabet. Deceptively simple with incredibly complex powers that you can’t even begin to explore fully. The Japanese call this Shibumi, but I can’t even explain that since I’m not Japanese.

It’s not simple vs. complex, it’s how do you merge the two in an elegant way. That’s where software needs to go, and why guys like Joel and Don piss me the hell off with their boolean logic rants.

Save the if-statement for code dorks.
  
There’s No ‘W’ In Coffee Dammit

New York is a very funny place. The people are really nice, if a bit “in your face” about things, but I really like that. It was annoying living in Vancouver, BC and having those two-faced bastards act like they are your best friends and then do some passive aggressive asshole maneuver behind your back. Man those folks are weird. At least New Yorkers are honest about how they feel about you, whether you like it or not.

There’s some really funny things I’ve noticed since I’ve been here though. When I point them out to other New Yorkers they kind of laugh and go, “Yeah, that’s right.” I say the same kinds of things to Vancouverites and they throw up their patent pending Righteous Indignation Force Field level 4. Then again, most of the annoying Vancouver behaviors were due to obnoxious hypocrisies. For example, I remember a picture in the Vancouver Sun of a group of women at a Kyoto protest who were standing in front of an SUV holding Starbucks coffee mugs and carrying paper and wood signs. My observations about New Yorkers are just funny and weird, not really annoying.

Cwoffee

I get coffee just about every day. What do you expect, I’m a programmer who has problems sleeping, so coffee is my best friend. Sweet caffeine give me strength. New York coffee is really good, probably some of the best I’ve had. It’s not bitter, usually very smooth, and cheap as hell with a small cup costing you .90 at the most.

But dammit if they don’t pronounce it “cwoffee”. “Would you like some cwoffee sir?” What’s even more weird about it is most of the other words are pretty normal to my average American ears. It’s just the cwoffee that drives me nuts. Everytime I hear someone say it I want to scream, “There’s no fucking ‘W’ in coffee! Shit! Can’t you idiots hear yourself? Coffee! Coffee! Coffee! See? I’m saying it and there’s no ‘W’ in coffee!”

Of course that would be the day I get the “special cwoffee” that had a turd floating in it the day before.

The Subway Is An Elevator

The subway in NYC is fantastic. It’s probably the best in the world. The only one that I think rivals it is the Seoul Korea subway system. In NYC you can go just about anywhere in, near, or around the city for just $70 per month. In contrast I had to pay $60 month in Vancouver and that only got me shitty buses inside one zone. There’s no zones in NYC and the buses and subway are just great. Sure they break down, but that’s probably more because the state doesn’t fund it as much as they should.

I’ve noticed though that people act like the subway is like an elevator. My international friends might not know this, but Americans (and Canadians) don’t talk in the elevator. Friends will be chatting, yelling, and fighting as the walk up to the elevator, but once they step in they SHUT THE FUCK UP! It’s funny because if you ignore this unwritten rule you get dirty looks. This is weird for New Yorkers because they don’t do the dirty look thing very well. New Yorkers will just tell you off. The problem is that the need to not talk in the elevator supersedes the need to tell you to shut up, so they use a dirty look.

In the subway it’s the same thing. I didn’t realize it until I saw a bunch of rowdy teens yelling and jumping as we approached the subway entrance. They were pushing and shoving and just being 16, but right when they got inside the subway they went dead quiet. They stayed quiet on the platform, on the train, off the train, and all the way up the stairs. The second they got back on the street it was like someone turned their obnoxious dial back up to “shithead” and they were back to their antics.

After this I started to see everyone doing it. Just like clockwork they would stop talking as soon as they entered the subway. I swear, the subway is an elevator here.

“And Jesus Said, ‘Place All Things In Paper Bags.’”

Hey, it’s the only explanation I have for people putting my cwoffee in paper bags. I swear. You’ll go to buy a small cwoffee from the corner. The guy will pour the coffee, put a lid on it, take a paper bag out, and put the coffee in the bag. This is so retarded I just have no way to explain it. It’s not like the cup needs extra protection. What would a paper bag do for the coffee cup anyway? All that happens is the coffee dribbles out and turns the bag into a brown blob of Folgers flavored papier mache.

Putting the coffee cup in the bag also tends to interfere with one of the primary requirements for handling coffee intelligently: keep the open end up. When it’s in the bag you can’t see whether you have it tilted or not. It’s covered with a very thin badly forming lid, so upright orientation is essential to smooth unburned skin.

I’ve asked people why they do this and usually they just look at me and say, “What? Uh, so it doesn’t spill.” What?! But, putting it in a bag is the last thing you want to do. I’m so confused.

OCD Nails

I can’t explain it, but the women here are just insane about their nails. Not only do they keep all digits perfectly manicured at all times, but they make sure that the polish matches whatever they happen to be wearing. I’d need a pantone color wheel to get anything this color coordinated.

Fashion Models Date Dirtbags

Along with my OCD Nails observations, I’ve also noticed that you’ll see a bunch of women who are dressed perfectly, but are with guys wearing the “dirtbag” look. She’ll have everything matching and newly done hair and nails, and he’ll have a torn t-shirt with a BBQ sauce stain on it. I guess you can get away with being a dirtbag when you’re 48% of the population (38% if you take away all the gay men).
The KitchenSink Language

I’ve started getting into language design more these days, and have several language related projects. While I’m far from a real language creator like this poetic guy, this gawky guy, this dude from Nippon, and this really anal guy who should have stayed a physicist, I do like it as a hobby.

One thing I’ve found royally annoying from beginning to intermediate programmers is they are so focused on the language and believe that the latest greatest “paradigm” will save us all. They point at some obscure language feature they enjoy and claim it’s so great. “Function programming closures…” or “Object polymorphism…” are usually how such rants start. There’s really two problems with this though:

It’s the platform stupid.
You claim this is true, but where’s your evidence computer scientist?
What do I mean by “It’s the platform stupid”? Well, I’m being slightly hypocritical here when I give the second statement, but the general idea is that the language doesn’t matter as much as the capabilities of the platform the language sits upon. Take Java as an example: It’s features aren’t really that different from any other language. There’s little bits of syntax and simplified things that C++ apparently did wrong, but in the end, it’s pretty much the same as C++. This is where most programmers say, “Yeah, but with Java I have a cross platform language, dynamic loading, tons of classes in a massive library…” Yes, you are right, but this is the platform not the language.

My general complaint about this is that the platform should be separated from the language and created for any language that wants to use it, but as long as programmers and language designers keep globbing languages and platforms together, we’ll never have this. The general proof of the advantage of separating language from the platform is also in Java as I can write an interpreter for the Java Virtual Machine rather quickly (as was done with Jython and many, many, other languages) and gain all of the advantages of the Java Platform, but without having to use any of the Java language. The nearly crisp division between language and platform resides at the point where you can implement another language on top of an existing language’s capabilities and support infrastructure. So, the JVM, Java Class libraries, java byte code, supporting libraries, and other goodies are easily separated from the Java language which focuses on how a while loop should be structured.

There is of course some interplay between the platform and the language,

otherwise there would be no binding between them. It’s only recently with the introduction of well designed scripting languages and heavily cross platform virtual machines that we’ve seen a true possibility to have an entirely separate platform (or runtime maybe?) from any language. I really think Microsoft has the right idea with the CLI: let any language run on it. I can forgive programmers maybe eight years ago because they didn’t have this really since you either were stuck with C++ and [insert favorite platform here] or you just couldn’t use C++ to do anything very useful. Also it was in a language designer’s interests to tightly couple their language to the runtime since they could more easily attract programmers to the language if the runtime had lots of nice goodies. And attracting followers really what counts in the religion and business of programming language promotion.

Now, this of course is just an argument, and I’m being hypocritical when I give my second complaint: “You claim this is true, but where’s your evidence computer scientist?” This one is really simple: if you are a language designer, and you claim your syntax, semantics, library or fundamental paradigm (especially that) is so fantastic, easy to learn, improved, superior, or other claim, then you should back it up with some empirical evidence. This is actually pretty easy to do, and there’s a huge part of Cognitive Science which is devoted to just studying how programmers use languages. You basically run a series of experiments to test your hypothesis, and publish your results for others to verify and criticize. I’m not being too hypocritical here because there actually is tons of research that shows software development is still too tedious and error prone.

What I usually hear from language designers is a laundry list of minuscule little features which are not really any better than any other language, and are usually just style differences. Many times a new “paradigm” (which is just a fancy way of slapping a “NEW!” sticker on something) is touted as being some fantastic advantage over what everyone else is doing, and then the language creator starts forcing students in some classes to learn it. This is done without any verification of the proposed claims and smacks so much of religious brain washing that it leaves a nasty taste in my mouth. If this is how languages are pushed, then stop calling it a science.

There are a few languages which were designed by testing the features on prospective users, and these languages tend to be really easy to use. Smalltalk and Python both come to mind as languages which meet this criteria. Also, many open source languages are typically put forth as a tool for others to use, and promoted like any other project, so they are basically doing this (although, some rigor would be nice). The people I’m complaining about are professors who tend to teach a language they have created, or which they advocate, but which they have done no usability testing or empirical analysis prior to forcing students to learn the language.

Functional programming advocates are the worst offenders of this. I personally like the idea behind functional programming, but the technique is just one more in my arsenal of problem solving techniques. It’s not the one true way as Schemers or Haskelites would have you think (and remember, it’s up to them to prove that, not me to disprove something which hasn’t been proven yet). Even though functional programming advocates can’t point me to any research into patterns, frameworks, re-usable platforms, or even simple “cook-books” of how to do things in their favorite language, they expect me to abandon my all my available tools and join their religion. Worst of all, they force their students to learn these languages (which are not used in industry very much, limiting the student’s marketability) because they know that programmers (and people) are generally lazy. It’s easier to slam every problem into a functional programming “nail” once you have learned your functional programming “hammer”.

The analogy I like to make about this aspect of computer science education is with a biology professor. Imagine you’re taking an introductory biology course as part of your pre-Med curriculum to become a Medical Doctor. This course is most likely going to be difficult, and intended to prepare you for professional work as a physician. Now, the first day, your professor comes in and announces that she “has discovered the meaning of life and it is ”Rael":http://www.rael.org/". She then insists that, in order to pass her class, you must learn all of Raelian science, write several articles for the local Raelian Gazzette, and participate in all Rael rallies. I bet you would probably complain wouldn’t you? Hell, you’d have her fired on the spot. Who is she to teach something so unscientific as Rael in a biology class!

Yet, you sit there when a computer science professor walks in a class and says, “I have discovered the best way to write software, and it is [insert catch phrase paradigm of the week] programming. You will be required to learn this language to pass my class. You will write several assignments in the language. You will be forced to attend labs in the language…” Why does he have the right to do this? Because there are no scientific standards in computer science. There are no peers yelling, “Hey! That hasn’t been peer reviewed, who the hell are you to teach that?” Nobody is standing up demanding that the latest language feature be tested and peer reviewed before it is forced on paying customers (students). Nope, they just go, “Oh, it’s new and he has a Ph.D., it must be correct then.” What is missing are the concepts of scientific method, empirical validation, experimentation, and peer review.

In other aspects of computer science (algorithm complexity, computational mathematics, cryptography, computational geometry, etc.) this is not the case. These are typically not empirical parts of the discipline (although, I think someone should do empirical validation before claiming an algorithm is faster than another) but rather based on mathematical logic. The fallacy that most computer scientists make is that the logic and rigor of these computational mathematics aspects applies to other parts of computers science where empirical evidence and experimentation are better analysis techniques. Generally, these areas involve anything to do with people: usability, graphics perceptions, interface design, language development, software engineering, process management, and many other human aspects of computer science. What needs to happen is for computer scientists to realize that these aspects are empirical and start following the rest of the scientific world (Biology, Physics, Psychology, Astrophysics, everything%20and%20apply%20statistical%20empirically%0Aexperimentation%20based%20analysis%20methods.%0A%0A%0A%0Ah2.%20If%20One%20Is%20Better,%20Ten%20Must%20Be%20The%20Best)

While that rant may seem overly long, it sets the stage for this language I’m putting together as kind of another INTERCAL. My impression of INTERCAL was that the designers intended to make fun of the ranting fools pushing Structured Programming (again, without any proof that it was superior). They took all the purported features and turned them on their head, creating a language that was nearly impossible to understand and work with.

With KitchenSink, I’m going to attempt to combine all of the features that language purists claim will make programming better. I figure, if one paradigm is better, then why not include them all! This language will be the best language in the world if you go by how language nuts (i.e. people who think the language and platform are married) rate the latest programming languages. I am going to try to make the language as simple as possible, but in the end, I believe it will be hopelessly useless, and only a novelty. Then again, I may hit onto something and actually make the best language in the world! (yeah, alright)

Here’s the short list of the super cool paradigms I’m gonna have in KitchenSink:

* Object-Oriented Programming — Can’t have a language without being a slave to the objects. Even better, my object design will be based on exemplars rather than class structured (another popular academia thingy). That’s where you don’t define your ontology, but rather just say, “this thing is like that thing with these differences”.

* Functional Programming — Functions will be first class objects, will have closures, and you’ll be encouraged to make them like crazy even if they don’t help the design one bit.

* Concatenative Programming — This latest and greatest language feature as promoted in Forth, Onyx, Joy, and PostScript (creates some wonderfully cryptic programs) and you know how conciseness is next to godliness with math junkies. Who cares if nobody can read it without a diagram of a massive complicated stack flow! It’s concise dammit!

* Templates and Aspect-Oriented Programming — Damn, some zealots have proclaimed that “Any language with a pre-processor is broken.” Rather than admit that meta-programming is really useful for creating generic components, we’ll just recast the pre-processor as “an Aspect-Oriented Compiler”, and start calling macros “templates”.

* Structured Programming — How could you possibly have any language that wasn’t also structured!? Heaven forbid you should create a nice interaction based language like Smalltalk. Nope, it has to be a lock step algorithm or it’s not “provable”.

* Logical Proofs and Design By Contract — It doesn’t matter that Design by Contract has been “proven” (through logic though) to be equivalent to Clean Room logical proofs. It doesn’t matter that a logic proof doesn’t prevent bugs during runtime. All that matters is that I make software development so difficult that only a trained math genius could ever write a piece of software. That will keep all those pesky H1-B visa carriers out of the business.

* Full Set Manipulation Operators — Hey, everything in a computer is just a set of some kind. Who needs easy to use indexing that follows what everyone was taught in high school algebra? Let’s do what R, Haskell, and now Python have done by making cryptic indexing possible.

* Tail Recursion — Hey, we’ve got functional programming, but damn making those stacks is really slow. What’s that? Why not just introduce that highly useful concept of “iteration”? Tisk-tisk. That’s not very purist of you. Are you sure you’re a member of the inner circle? I could have sworn that iteration was a forbidden word in the functional religion. We call that “tail recursion” here. Maybe you should go to the end of the line.

* *Lots and Lots of Idiotic Silly Operators (LLISO)* — Programming’s all about problem solving, and nothing is more fun than reading tons of symbols that, when combined, must be carefully taken apart to understand what’s really going on. That really makes the language a wonderful puzzle that needs to be solved (because, as an academic, I don’t really need to be solving puzzles with the language, I want to solve them in the language). Even better is when these symbols are the inverse of what everyone else is familiar with using. The main advantage of this is that I can force the user to adopt symbols and structuring constraints which makes my compiler design so much easier. Who needs expressiveness when you have a massive Perceived I.Q. booster like Lisp Parentheses and wonderful stuff like CADR, CDDR, CADDR, and CDDRDDADR!? Hey, that reminds me, most programmers can’t type, so let’s save keystrokes at every turn and use acronyms and abrvt. kywrds.

* Built-In Finite State Machine Processing — FSMs are these wonderfully mathematically correct little things that can do just about anything a language can do, so why not incorporate them right in the language? Sure there’s a cognitive limit to the complexity of an FSM, and sure they become nearly incomprehensible when combined with other FSMs (and possibly unprovable), but it’s all about mathematics, not usability here. As long as I can do some sort of mathematical proof on the program, even if that proof only works in an unrealistically constrained environment, I can be sure that my program will always work. Let’s just hope nobody installs it on a new computer or uses it for anything it wasn’t intended for originally. Nobody does that right? Things don’t change right?

I think that list of features should keep me busy for a while. When it’s done, it will be the most powerful, most useful, most capable language in the world! Simply using all of these great new paradigms will surely win me some kind of award.